
# 1. å…ˆéªŒçŸ¥è¯†

## 1.1 ä¸‰å¥—ä½“ç³»å¯¹æ¯”

| ç»´åº¦         | x86          | RISC-V      | ARM     |
| ------------ | ------------ | ----------- | ------- |
| æœ€é«˜ç¡¬ä»¶æ§åˆ¶ | BIOS + MSR   | **M-mode**  | **EL3** |
| Hypervisor   | VMX root     | **HS-mode** | **EL2** |
| OS å†…æ ¸      | ring0        | **S-mode**  | **EL1** |
| ç”¨æˆ·æ€       | ring3        | **U-mode**  | **EL0** |
| CPUå·¥ä½œæ¨¡å¼  | å® / ä¿ / é•¿ | æ—           | æ—       |



## 1.2 x86 çš„â€œè¿è¡Œæ¨¡å¼â€

### ğŸ”¹ å®æ¨¡å¼ï¼ˆReal Modeï¼‰

- ä¸Šç”µé»˜è®¤
- 16 ä½
- **æ²¡æœ‰ç‰¹æƒçº§ï¼ˆring ä¸ç”Ÿæ•ˆï¼‰**
- æ²¡æœ‰è™šæ‹Ÿå†…å­˜
- DOS æ—¶ä»£

------

### ğŸ”¹ ä¿æŠ¤æ¨¡å¼ï¼ˆProtected Modeï¼‰

- 32 ä½
- **å¼•å…¥ ring0â€“3**
- åˆ†æ®µ + åˆ†é¡µ
- 80386 å¼€å§‹

------

### ğŸ”¹ é•¿æ¨¡å¼ï¼ˆLong Modeï¼‰

- 64 ä½
- ç°ä»£ Linux / Windows
- åˆ†æ®µå‡ ä¹åºŸå¼ƒ
- ring0â€“3 ä»ç„¶å­˜åœ¨

## 1.3 VMCS

VMCSï¼ˆVirtual Machine Control Structureï¼‰å°±æ˜¯ CPU ç”¨æ¥â€œæè¿°å’Œæ§åˆ¶ä¸€å°è™šæ‹Ÿæœºâ€çš„ç¡¬ä»¶æ•°æ®ç»“æ„ã€‚

### 1.3.1 VMCS åœ¨ VT-x é‡Œçš„ä½ç½®ï¼ˆå¾ˆå…³é”®ï¼‰

VT-x çš„æ‰§è¡Œæ¨¡å‹æ˜¯ï¼š

```
VMX root mode      â†’ Hypervisor
VMX non-root mode  â†’ Guest OS
```

è€Œ **VMCS å°±æ˜¯ CPU åœ¨è¿™ä¸¤ä¸ªæ¨¡å¼ä¹‹é—´åˆ‡æ¢æ—¶å”¯ä¸€å‚è€ƒçš„æ•°æ®ç»“æ„**ã€‚

### 1.3.2 VMCS é•¿ä»€ä¹ˆæ ·ï¼ˆç¡¬ä»¶è§†è§’ï¼‰

#### 1ï¸âƒ£ ä¸æ˜¯æ™®é€šå†…å­˜ç»“æ„

- VMCS åœ¨ **å†…å­˜ä¸­**
- ä½† **CPU æŒ‰â€œå­—æ®µ IDâ€è®¿é—®**
- ä½ ä¸èƒ½ `struct vmcs { ... }` ç›´æ¥è¯»å†™

è®¿é—®æ–¹å¼åªèƒ½æ˜¯ï¼š

```
VMREAD
VMWRITE
```

------

#### 2ï¸âƒ£ VMCS çš„ç”Ÿå‘½å‘¨æœŸ

```
vmxon
  â†“
vmclear   â†’ åˆå§‹åŒ– VMCS
  â†“
vmptrld   â†’ å‘Šè¯‰ CPUï¼šç”¨è¿™ä¸ª VMCS
  â†“
vmlaunch / vmresume
```

### 1.3.3 MCS çš„å››å¤§ç±»å­—æ®µ

Intel æ‰‹å†ŒæŠŠ VMCS åˆ†ä¸º **4 å¤§å—**ï¼š

------

#### 1ï¸âƒ£ Guest-State Areaï¼ˆGuest çŠ¶æ€ï¼‰

> **Guest OS ä»¥ä¸ºè‡ªå·±æ­£åœ¨è¿è¡Œçš„ CPU çŠ¶æ€**

åŒ…æ‹¬ï¼š

- é€šç”¨å¯„å­˜å™¨ï¼ˆéƒ¨åˆ†ï¼‰
- CR0 / CR3 / CR4
- RIP / RSP / RFLAGS
- æ®µå¯„å­˜å™¨ï¼ˆCS/DS/SSâ€¦ï¼‰
- MSRï¼ˆéƒ¨åˆ†ï¼‰

------

#### 2ï¸âƒ£ Host-State Areaï¼ˆHost çŠ¶æ€ï¼‰

> **VM-exit æ—¶ CPU è¦è‡ªåŠ¨æ¢å¤çš„ hypervisor çŠ¶æ€**

åŒ…æ‹¬ï¼š

- Host CR3
- Host RIP / RSP
- Host æ®µå¯„å­˜å™¨
- Host MSR

âš ï¸ å¦‚æœ Host-State é…é”™ï¼š

- VM-exit ä¼šç›´æ¥ triple fault / reset

------

#### 3ï¸âƒ£ VM-Execution Controlsï¼ˆæ‰§è¡Œæ§åˆ¶ï¼‰

> **æ§åˆ¶ Guestâ€œå“ªäº›æ“ä½œä¼šè§¦å‘ VM-exitâ€**

ä¾‹å¦‚ï¼š

- æ‰§è¡Œ `CPUID` æ˜¯å¦ trap
- `HLT` æ˜¯å¦ trap
- I/O æŒ‡ä»¤æ˜¯å¦ trap
- CR è®¿é—®æ˜¯å¦ trap
- MSR è®¿é—®æ˜¯å¦ trap

------

#### 4ï¸âƒ£ VM-Exit / VM-Entry Controls

> **æ§åˆ¶ VM è¿›å‡ºæ—¶ CPU çš„è¡Œä¸º**

åŒ…æ‹¬ï¼š

- è‡ªåŠ¨ä¿å­˜ / åŠ è½½å“ªäº›å¯„å­˜å™¨
- MSR è‡ªåŠ¨åˆ‡æ¢
- EFER / PAT å¤„ç†
- EPT ç›¸å…³æ§åˆ¶

### 1.3.4 VM-exit / VM-entry å’Œ VMCS çš„å…³ç³»

#### 1ï¸âƒ£ VM-entry

```
Host â†’ Guest
```

CPUï¼š

- ä» VMCS çš„ **Guest-State** è£…è½½å¯„å­˜å™¨
- åˆ‡æ¢åˆ° VMX non-root

------

#### 2ï¸âƒ£ VM-exit

```
Guest â†’ Host
```

CPUï¼š

- æŠŠ Guest çŠ¶æ€å†™å› VMCS
- ä» VMCS çš„ **Host-State** æ¢å¤å¯„å­˜å™¨
- è¿›å…¥ VMX root

# 2. å®ç°è™šæ‹ŸåŒ–å…·ä½“éœ€è¦åšçš„å·¥ä½œ

------

## 1ï¸âƒ£ è£¸æœº or å†…æ ¸æ€ç¯å¢ƒ

å¿…é¡»è¿è¡Œåœ¨ **ring 0**ï¼š

- é€‰æ‹©ä¹‹ä¸€ï¼š
  - è£¸æœºï¼ˆbootloader + è‡ªå·±çš„å†…æ ¸ï¼‰
  - Linux å†…æ ¸æ¨¡å—ï¼ˆåƒ KVMï¼‰
- ä¸èƒ½ï¼š
  - ç”¨æˆ·æ€ç¨‹åº

------

## 2ï¸âƒ£ CPU & BIOS èƒ½åŠ›æ£€æµ‹

### å·¥ä½œå†…å®¹

- CPUID æ£€æŸ¥ VT-xï¼š

  ```
  CPUID(1).ECX[5]
  ```

- BIOS æ˜¯å¦å¼€å¯ VT-x

- è¯» `IA32_FEATURE_CONTROL`ï¼ˆMSR 0x3Aï¼‰

### è¦å†™çš„ä»£ç 

- cpuid wrapper
- rdmsr / wrmsr

------

## 3ï¸âƒ£ å¼€å¯ VMXï¼ˆç¡¬ä»¶æ¨¡å¼åˆ‡æ¢ï¼‰

### å¿…é¡»æ­¥éª¤ï¼ˆä¸¥æ ¼é¡ºåºï¼‰

1. è®¾ç½® CR4.VMXE = 1
2. åˆ†é… VMXON regionï¼ˆ4KB å¯¹é½ï¼‰
3. å†™ VMX revision id
4. `VMXON`

ä»»ä½•ä¸€æ­¥é”™ï¼š

- `#GP`
- æˆ– VM-instruction error

------

## 4ï¸âƒ£ æ„é€  VMCSï¼ˆæœ€æ ¸å¿ƒã€æœ€éš¾ï¼‰

### 4.1 VMCS å†…å­˜

- 4KB å¯¹é½
- `VMCLEAR`
- `VMPTRLD`

------

### 4.2 Guest Stateï¼ˆæœ€å°é›†ï¼‰

è¦â€œå‡è£…â€ä¸€å° CPUï¼š

- RIPï¼ˆGuest ç¨‹åºå…¥å£ï¼‰
- RSP
- RFLAGS
- CR0 / CR3 / CR4
- CS / SS / DS / ES
- GDTR / IDTR

------

### 4.3 Host Stateï¼ˆæ•‘å‘½ç»³ï¼‰

VM-exit æ—¶ CPU è‡ªåŠ¨æ¢å¤ï¼š

- Host RIPï¼ˆVM-exit handlerï¼‰
- Host RSP
- Host CR3
- Host CS / SS

â— **è¿™é‡Œé”™ = ç›´æ¥æ­»æœº**

------

### 4.4 VM Execution Controls

æœ€å°ç­–ç•¥ï¼š

- æ‰€æœ‰æ•æ„ŸæŒ‡ä»¤éƒ½ VM-exit
- CPUIDã€HLTã€I/O å…¨ trap

------

## 5ï¸âƒ£ å†…å­˜è™šæ‹ŸåŒ–ï¼ˆæœ€ç®€ç‰ˆï¼‰

### MVP æ–¹æ¡ˆï¼šä¸åš EPT

- Guest CR3 = Host CR3
- Guest å’Œ Host å…±ç”¨é¡µè¡¨
- Guest ä»£ç ç›´æ¥æ˜ å°„åˆ° Host å†…å­˜

ğŸ‘‰ **è¿™ä¸æ˜¯å®‰å…¨çš„ï¼Œä½†æœ€ç®€å•**

------

## 6ï¸âƒ£ VM-entry

```
VMLAUNCH
```

- æˆåŠŸ â†’ è¿›å…¥ Guest
- å¤±è´¥ â†’ æŸ¥ VM-instruction error å­—æ®µ

------

## 7ï¸âƒ£ VM-exit å¤„ç†

### å¿…é¡»å†™ï¼š

- VM-exit handler
- è¯»å– exit reason
- æ ¹æ® reason åšæœ€å°å¤„ç†ï¼š
  - CPUID â†’ æ¨¡æ‹Ÿ
  - HLT â†’ é€€å‡º Guest
  - å…¶ä»– â†’ panic

------

## 8ï¸âƒ£ Guest ä»£ç 

æœ€ç®€å• Guestï¼š

```
mov eax, 0x1234
hlt
```



# 3. ç‰¹åˆ«å…³æ³¨

## 1ï¸âƒ£ å¼€å¯ VMXï¼ˆCR0 / CR4 å›ºå®šä½æ˜¯ç¬¬ä¸€æ­»äº¡ç‚¹ï¼‰

```rust
fn enable_vmx() {
    // è¯»å– VMX å›ºå®šä½ MSR
    let cr0_fixed0 = rdmsr(IA32_VMX_CR0_FIXED0);
    let cr0_fixed1 = rdmsr(IA32_VMX_CR0_FIXED1);
    let cr4_fixed0 = rdmsr(IA32_VMX_CR4_FIXED0);
    let cr4_fixed1 = rdmsr(IA32_VMX_CR4_FIXED1);

    // ä¿®æ­£ CR0 / CR4
    let mut cr0 = read_cr0();
    cr0 |= cr0_fixed0;
    cr0 &= cr0_fixed1;
    write_cr0(cr0);

    let mut cr4 = read_cr4();
    cr4 |= cr4_fixed0;
    cr4 &= cr4_fixed1;
    cr4 |= CR4_VMXE;
    write_cr4(cr4);

    // VMXON
    vmxon(&VMXON_REGION_PHYS_ADDR);
}
```

### è¿™é‡Œåœ¨é˜²ä»€ä¹ˆï¼Ÿ

ğŸ‘‰ **VM-entry failure: invalid control register**

### Intel æ‰‹å†Œå¯¹åº”ä½ç½®

- **Vol 3C**

  - **24.6.1**: *â€œCR0 and CR4 Fixed Bitsâ€*

  - æ˜ç¡®å†™ç€ï¼š

    > Bits set in IA32_VMX_CR0_FIXED0 must be set in CR0
    >  Bits clear in IA32_VMX_CR0_FIXED1 must be clear in CR0
    >  Otherwise VM-entry fails

## 2ï¸âƒ£ VMCS åˆå§‹åŒ–ï¼ˆæ®µå¯„å­˜å™¨ / TR æ˜¯ç¬¬äºŒæ­»äº¡ç‚¹ï¼‰

```rust
fn setup_vmcs() {
    vmclear(&VMCS_PHYS_ADDR);
    vmptrld(&VMCS_PHYS_ADDR);

    // ===== Host state =====
    vmwrite(HOST_CR0, read_cr0());
    vmwrite(HOST_CR3, read_cr3());
    vmwrite(HOST_CR4, read_cr4());

    vmwrite(HOST_CS_SELECTOR, read_cs());
    vmwrite(HOST_TR_SELECTOR, read_tr());

    vmwrite(HOST_RIP, vmexit_entry as u64);
    vmwrite(HOST_RSP, host_stack_top());

    // ===== Guest state =====
    vmwrite(GUEST_CR0, read_cr0());
    vmwrite(GUEST_CR3, guest_cr3());
    vmwrite(GUEST_CR4, read_cr4());

    vmwrite(GUEST_CS_SELECTOR, guest_cs());
    vmwrite(GUEST_CS_AR_BYTES, CODE_SEG_AR);
    vmwrite(GUEST_CS_LIMIT, 0xffff_ffff);

    vmwrite(GUEST_TR_SELECTOR, guest_tr());
    vmwrite(GUEST_TR_AR_BYTES, TSS_AR);

    vmwrite(GUEST_RIP, guest_entry());
    vmwrite(GUEST_RSP, guest_stack_top());
    vmwrite(GUEST_RFLAGS, 0x2); // bit1 å¿…é¡»æ˜¯ 1
}
```

------

### âš ï¸ è¿™é‡Œæœ€å®¹æ˜“æ­»çš„ 3 ä¸ªç‚¹

#### â‘  TRï¼ˆä»»åŠ¡å¯„å­˜å™¨ï¼‰éæ³•

- base / limit / AR ä¸åˆæ³•
- selector = 0

ğŸ‘‰ **ç›´æ¥ VM-entry failure**

#### â‘¡ CS/SS çš„ AR bits ä¸åŒ¹é… long mode

- L-bit / D-bit é”™è¯¯ç»„åˆ

#### â‘¢ RFLAGS bit 1 = 0

### ä¸ºä»€ä¹ˆ VMCS æ˜¯â€œæœ€å±é™©çš„ä¸œè¥¿â€

- VMCS æ˜¯ä¸€ä¸ªï¼š

  - éšå¼çŠ¶æ€æœº
  - æœ‰å¤§é‡**äº’ç›¸çº¦æŸçš„å­—æ®µ**

- Intel æ‰‹å†Œé‡Œå¤§é‡è¿™ç§è¯ï¼š

  > â€œIf X = 1 then Y must be Z or VM-entry failsâ€

### intel æ‰‹å†Œå¯¹åº”ä½ç½®ï¼ˆé‡ç‚¹ï¼‰

- **Vol 3C**
  - **26.3.1.2** *â€œChecks on Guest Segment Registersâ€*
  - **26.2.1** *â€œChecks on Host Segment Registersâ€*

é‡Œé¢å¤§é‡è¿™ç§å¥å¼ï¼š

> If the guest is in IA-32e mode,
>  then the CS segment must have L=1 and D=0;
>  otherwise VM-entry fails.

> If the TR is unusable,
>  then VM-entry fails.

## 3ï¸âƒ£ VM-execution controlsï¼ˆå°‘æ‹¦æˆªï¼‰

```
fn setup_vm_controls() {
    let mut pinbased = PIN_BASED_EXT_INT_EXITING;
    let mut primary = CPU_BASED_HLT_EXITING | CPU_BASED_CPUID_EXITING;

    // ä¸€å¼€å§‹ä¸è¦æ‰“å¼€ä¸€å † exiting
    primary &= !CPU_BASED_CR3_LOAD_EXITING;
    primary &= !CPU_BASED_CR3_STORE_EXITING;

    vmwrite(PIN_BASED_VM_EXEC_CONTROL, adjust(pinbased));
    vmwrite(CPU_BASED_VM_EXEC_CONTROL, adjust(primary));

    vmwrite(VM_ENTRY_CONTROLS, adjust(VMENTRY_IA32E_MODE));
}
```

------

### Intel æ‰‹å†Œå¯¹åº”ä½ç½®

- **Vol 3C**
  - **24.6.2** *â€œProcessor-Based VM-Execution Controlsâ€*
  - **26.2.1** *â€œVM-Entry Control Fieldsâ€*

å…¸å‹åŸæ–‡ç»“æ„ï¼š

> If the â€œIA-32e mode guestâ€ VM-entry control is 1,
>  then the guest must be in IA-32e mode;
>  otherwise VM-entry fails.

## 4ï¸âƒ£ EPTï¼šèƒ½è·‘å°±è¡Œï¼ˆé¿å… EPT misconfigï¼‰

```
fn setup_ept() {
    let eptp = EptPointer {
        memory_type: WB,
        page_walk_len: 4,
        root: &EPT_PML4,
    };

    vmwrite(EPT_POINTER, eptp.raw());
}
```

### Intel æ‰‹å†Œå¯¹åº”ä½ç½®

- **Vol 3C**
  - **28.2.3** *â€œEPT Misconfigurationsâ€*

åŸæ–‡é£æ ¼ï¼š

> If any EPT paging-structure entry is misconfigured,
>  an EPT misconfiguration VM-exit occurs.

ï¼ˆè¿™ç§ exit åŸºæœ¬ä¸å¯æ¢å¤ï¼‰

------

## 5ï¸âƒ£ VMEXIT handlerï¼ˆGuest RIP å¿…é¡»å‰è¿›ï¼‰

```
extern "C" fn vmexit_handler() {
    let reason = vmread(VM_EXIT_REASON);

    match reason {
        EXIT_REASON_CPUID => {
            emulate_cpuid();
            advance_rip();
        }
        EXIT_REASON_HLT => {
            schedule();
            advance_rip();
        }
        EXIT_REASON_EPT_VIOLATION => {
            fix_ept();
        }
        _ => panic!("Unhandled VMEXIT"),
    }

    vmresume();
}
```

# 4. ç›®æ ‡

å®ç° x86_64 æ¶æ„çš„æœ€å°è™šæ‹ŸåŒ–ï¼Œè¾¾åˆ° h_1_0ï¼ˆRISC-V è™šæ‹ŸåŒ–ï¼‰çš„æœ€ç»ˆæ•ˆæœï¼Œå³ï¼š
- æˆåŠŸåˆ›å»ºå’Œåˆå§‹åŒ–è™šæ‹Ÿæœº
- æˆåŠŸå¯åŠ¨ guest æ“ä½œç³»ç»Ÿ
- Guest èƒ½å¤Ÿæ‰§è¡Œ HLT æŒ‡ä»¤å¹¶è§¦å‘ VM-exit
- Hypervisor èƒ½å¤Ÿå¤„ç† VM-exit å¹¶æ­£ç¡®è¿”å›

---

# 5. å·²å®Œæˆçš„å·¥ä½œ

## 5.1 VMX (Virtual Machine Extensions) åŸºç¡€è®¾æ–½

### 5.1.1 VMX åˆå§‹åŒ–

**ä½ç½®**: `src/vmx.rs` - `vmx_init()` å‡½æ•°

**åŠŸèƒ½**:
- æ£€æŸ¥ CPU æ˜¯å¦æ”¯æŒ VT-x (è¯»å– CPUID å’Œ IA32_FEATURE_CONTROL_MSR)
- å¯ç”¨ VMX æ¨¡å¼ (è®¾ç½® CR4.VMXE ä½)
- åˆ†é…å¹¶åˆå§‹åŒ– VMXON åŒºåŸŸ
- æ‰§è¡Œ VMXON æŒ‡ä»¤è¿›å…¥ VMX root operation æ¨¡å¼

**å…³é”®ä»£ç **:
```rust
pub fn vmx_init() {
    // Enable VMX in CR4
    enable_vmx_cr4();
    
    // Allocate VMXON region (4KB aligned)
    let vmxon_region = alloc::alloc::alloc_zeroed(
        alloc::alloc::Layout::from_size_align(4096, 4096).unwrap()
    ) as u64;
    
    // Set revision ID in VMXON region
    let vmx_basic = read_msr(MSR_IA32_VMX_BASIC);
    let revision_id = vmx_basic & 0x7FFFFFFF;
    *(vmxon_region as *mut u32) = revision_id as u32;
    
    // Execute VMXON
    let success = vmxon_phys(vmxon_paddr);
}
```

**è¯´æ˜**:
- **VMXON**: è¿›å…¥ VMX root operation æ¨¡å¼çš„æŒ‡ä»¤
- **VMXON åŒºåŸŸ**: å¿…é¡»å¯¹é½åˆ° 4KBï¼ŒåŒ…å« VMCS revision ID
- **VMX root operation**: Hypervisor çš„ç‰¹æƒæ¨¡å¼ï¼Œå¯ä»¥æ‰§è¡Œ VMX æŒ‡ä»¤
- **VMX non-root operation**: Guest æ“ä½œç³»ç»Ÿçš„éç‰¹æƒæ¨¡å¼

### 5.1.2 VMCS (Virtual Machine Control Structure)

**ä½ç½®**: `src/vmx.rs` - `setup_vmcs()` å‡½æ•°

**åŠŸèƒ½**:
- åˆ†é…å¹¶åˆå§‹åŒ– VMCS (Virtual Machine Control Structure)
- é…ç½® processor-based controls
- é…ç½® VM-entry controls
- é…ç½® VM-exit controls
- è®¾ç½® guest å’Œ host çŠ¶æ€

**VMCS å…³é”®å­—æ®µ**:

| å­—æ®µ | æè¿° | å€¼ |
|------|------|-----|
| VMCS_PIN_BASED_CTLS | Pin-based controls | 0x16 |
| VMCS_PROC_BASED_CTLS | Processor-based controls | 0xfff9fffe (å¯ç”¨ unrestricted guest å’Œ EPT) |
| VMCR_VM_EXIT_CONTROLS | VM-exit controls | 0xffffff (64-bit host address space) |
| VMCR_VM_ENTRY_CONTROLS | VM-entry controls | 0x1e000 (ç¦ç”¨ IA-32e mode) |

**è¯´æ˜**:
- **VMCS**: æ§åˆ¶è™šæ‹Ÿæœºè¡Œä¸ºçš„å†…å­˜ç»“æ„ï¼ŒåŒ…å« guest çŠ¶æ€ã€host çŠ¶æ€å’Œæ§åˆ¶å­—æ®µ
- **Processor-based controls**: æ§åˆ¶ VMX è¡Œä¸ºï¼ŒåŒ…æ‹¬ HLT exitingã€EPT ç­‰
- **Unrestricted guest**: å…è®¸ guest è¿è¡Œåœ¨å®æ¨¡å¼æˆ–ä¿æŠ¤æ¨¡å¼ï¼Œæ— éœ€æ»¡è¶³ IA-32e çº¦æŸ
- **EPT**: æ‰©å±•é¡µè¡¨ï¼Œå®ç° guest ç‰©ç†åœ°å€åˆ°ä¸»æœºç‰©ç†åœ°å€çš„æ˜ å°„

### 5.1.3 Guest çŠ¶æ€é…ç½®

**ä½ç½®**: `src/main.rs` - `prepare_guest_context()` å‡½æ•°

**åŠŸèƒ½**:
- è®¾ç½® guest é€šç”¨å¯„å­˜å™¨ (RIP, RSP, RFLAGS)
- è®¾ç½® guest æ§åˆ¶å¯„å­˜å™¨ (CR0, CR3, CR4)
- è®¾ç½® guest æ®µå¯„å­˜å™¨ (CS, DS, ES, SS, FS, GS, LDTR, TR)
- è®¾ç½® guest GDTR/IDTR

**é…ç½®è¯¦æƒ…**:

| å¯„å­˜å™¨ | å€¼ | è¯´æ˜ |
|--------|-----|------|
| CR0 | 0x80010001 | PE=1, PG=1 (64-bit long mode) |
| CR3 | guest_pagetable_paddr | Guest é¡µè¡¨åŸºå€ |
| CR4 | 0x00002020 | VMXE=1, PAE=1 |
| RIP | 0x100000 | Guest å…¥å£ç‚¹ |
| RSP | 0x100000 | Guest æ ˆæŒ‡é’ˆ |
| RFLAGS | 0x202 | IF=1, bit 1=1 |
| CS Selector | 0x8 | GDT code segment |
| CS AR | 0x909B | 64-bit code segment (L=1, D=0) |
| DS/ES/SS Selector | 0x10 | GDT data segment |
| DS/ES/SS AR | 0xC013 | 32-bit data segment |

**è¯´æ˜**:
- **64-bit long mode**: éœ€è¦ CR0.PE=1, CR0.PG=1, CR4.PAE=1, IA32_EFER.LMA=1
- **CS.L=1**: è¡¨ç¤º 64-bit ä»£ç æ®µ
- **æ®µæè¿°ç¬¦æ ¼å¼**: åŒ…å« base, limit, access rights, flags
- **GDTR/IDTR**: å…¨å±€æè¿°ç¬¦è¡¨å’Œä¸­æ–­æè¿°ç¬¦è¡¨å¯„å­˜å™¨

## 5.2 å†…å­˜ç®¡ç†

### 5.2.1 GDT (Global Descriptor Table)

**ä½ç½®**: `src/main.rs` - `create_gdt()` å‡½æ•°

**åŠŸèƒ½**:
- åˆ›å»º 64-bit æ¨¡å¼çš„ GDT
- åŒ…å« null æè¿°ç¬¦ã€ä»£ç æ®µã€æ•°æ®æ®µ

**GDT æ¡ç›®**:

| æ¡ç›® | åç§» | å€¼ | æè¿° |
|------|------|-----|------|
| Entry 0 | 0x00 | 0x0000000000000000 | Null æè¿°ç¬¦ |
| Entry 1 | 0x08 | 0x00CF9B000000FFFF | 32-bit ä»£ç æ®µ |
| Entry 2 | 0x10 | 0x00CF93000000FFFF | 32-bit æ•°æ®æ®µ |

**è¯´æ˜**:
- **GDT**: å…¨å±€æè¿°ç¬¦è¡¨ï¼Œå®šä¹‰ä»£ç æ®µã€æ•°æ®æ®µã€ç³»ç»Ÿæ®µ
- **æ®µæè¿°ç¬¦æ ¼å¼**: 64-bitï¼ŒåŒ…å« base addressã€limitã€access rights
- **Selector**: æ®µé€‰æ‹©å­ï¼ŒæŒ‡å‘ GDT æ¡ç›®

### 5.2.2 IDT (Interrupt Descriptor Table)

**ä½ç½®**: `src/main.rs` - `create_idt()` å‡½æ•°

**åŠŸèƒ½**:
- åˆ›å»º 64-bit æ¨¡å¼çš„ IDT
- åŒ…å« 256 ä¸ªä¸­æ–­é—¨æè¿°ç¬¦ï¼ˆå½“å‰éƒ½è®¾ç½®ä¸º 0ï¼‰

**è¯´æ˜**:
- **IDT**: ä¸­æ–­æè¿°ç¬¦è¡¨ï¼Œå®šä¹‰ä¸­æ–­å¤„ç†ç¨‹åºå…¥å£
- **IDT æ¡ç›®**: 16 å­—èŠ‚ï¼ŒåŒ…å« offsetã€selectorã€type ç­‰å­—æ®µ

### 5.2.3 Guest é¡µè¡¨ (Identity Paging)

**ä½ç½®**: `src/main.rs` - `create_identity_pagetable()` å‡½æ•°

**åŠŸèƒ½**:
- åˆ›å»º 4 çº§é¡µè¡¨ (PML4 -> PDP -> PD -> PT)
- å®ç° identity mappingï¼ˆçº¿æ€§åœ°å€ = ç‰©ç†åœ°å€ï¼‰
- æ˜ å°„å‰ 6MB å†…å­˜ï¼ˆ0x000000 - 0x600000ï¼‰

**é¡µè¡¨ç»“æ„**:
```
PML4 (Page Map Level 4)
  â””â”€ PDP (Page Directory Pointer Table)
      â””â”€ PD (Page Directory)
          â””â”€ PT (Page Table)
              â””â”€ 4KB é¡µé¢
```

**è¯´æ˜**:
- **4 çº§é¡µè¡¨**: 64-bit æ¨¡å¼ä½¿ç”¨ 4 çº§é¡µè¡¨ç»“æ„
- **Identity mapping**: çº¿æ€§åœ°å€ç›´æ¥æ˜ å°„åˆ°ç›¸åŒçš„ç‰©ç†åœ°å€
- **PTE æ ¼å¼**: åŒ…å«ç‰©ç†åœ°å€ã€Presentã€R/Wã€U/S ç­‰æ ‡å¿—

## 5.3 EPT (Extended Page Tables)

### 5.3.1 EPT æ¦‚å¿µ

**åŠŸèƒ½**:
- å®ç° guest ç‰©ç†åœ°å€ (GPA) åˆ°ä¸»æœºç‰©ç†åœ°å€ (HPA) çš„æ˜ å°„
- æä¾›å†…å­˜è™šæ‹ŸåŒ–ï¼Œé¿å… guest ä¿®æ”¹ host é¡µè¡¨

**EPT ç»“æ„**:
```
GPA (Guest Physical Address)
  â””â”€ EPT PML4
      â””â”€ EPT PDP
          â””â”€ EPT PD
              â””â”€ EPT PT
                  â””â”€ HPA (Host Physical Address)
```

**è¯´æ˜**:
- **EPTP (EPT PML4 Pointer)**: æŒ‡å‘ EPT æ ¹é¡µè¡¨çš„æŒ‡é’ˆ
- **EPT violation**: å½“ EPT æ˜ å°„å¤±è´¥æˆ–æƒé™ä¸åŒ¹é…æ—¶è§¦å‘ VM-exit
- **EPT memory types**: WB (Write-Back), UC (Uncacheable) ç­‰

### 5.3.2 EPT é…ç½®

**ä½ç½®**: `src/vmx.rs` - `setup_vmcs()` å‡½æ•°

**å…³é”®é…ç½®**:
```rust
// è®¾ç½® EPT pointer
let eptp = (ept_root & !0xFFF) | 0x3e; // walk_length=3, mem_type=6 (WB)
vmwrite(VMCS_EPT_POINTER, eptp as u64);
```

**è¯´æ˜**:
- **EPTP æ ¼å¼**: bits 51:12 = PML4 address, bits 5:3 = walk_length, bits 2:0 = memory_type
- **walk_length=3**: è¡¨ç¤º 4 çº§ EPT é¡µè¡¨ç»“æ„
- **mem_type=6**: WB (Write-Back) å†…å­˜ç±»å‹

## 5.4 Guest äºŒè¿›åˆ¶åŠ è½½

**ä½ç½®**: `src/loader.rs`

**åŠŸèƒ½**:
- ä»æ–‡ä»¶ç³»ç»ŸåŠ è½½ guest äºŒè¿›åˆ¶æ–‡ä»¶
- æ˜ å°„åˆ° guest åœ°å€ç©ºé—´
- è¿”å› guest å…¥å£åœ°å€

**å…³é”®ä»£ç **:
```rust
pub fn load_vm_image(
    path: &str,
    aspace: &mut AddrSpace,
) -> AxResult<(u64, usize, usize)> {
    // 1. æ‰“å¼€æ–‡ä»¶
    let (image_file, image_size) = open_image_file(path)?;
    
    // 2. åˆ†é…å†…å­˜å¹¶è¯»å– ELF æ–‡ä»¶
    let buffer = alloc::alloc::alloc(Layout::from_size_align(image_size, 1).unwrap());
    
    // 3. è§£æ ELF å¹¶åŠ è½½åˆ° aspace
    load_elf(image_file, buffer, aspace)?;
    
    // 4. è¿”å›å…¥å£ç‚¹å’Œå¤§å°
    Ok((entry_vaddr, image_size, load_vaddr))
}
```

**è¯´æ˜**:
- **ELF æ ¼å¼**: Executable and Linkable Formatï¼Œå¯æ‰§è¡Œå’Œå¯é“¾æ¥æ ¼å¼
- **aspace**: åœ°å€ç©ºé—´ï¼Œç®¡ç†å†…å­˜æ˜ å°„
- **EPT æ˜ å°„**: åŠ è½½çš„ä»£ç é€šè¿‡ EPT æ˜ å°„åˆ° guest ç‰©ç†å†…å­˜

## 5.5 VM-Exit å¤„ç†

**ä½ç½®**: `src/vmx.rs` - `vmx_launch()` å‡½æ•°

**åŠŸèƒ½**:
- æ‰§è¡Œ VMLAUNCH æŒ‡ä»¤å¯åŠ¨ guest
- å¤„ç† VM-exit
- è¿”å›é€€å‡ºåŸå› å’Œ guest çŠ¶æ€

**VM-Exit åŸå› **:
- **HLT**: guest æ‰§è¡Œ HLT æŒ‡ä»¤
- **EPT violation**: EPT è®¿é—®å¤±è´¥
- **CR access**: guest è®¿é—®æ§åˆ¶å¯„å­˜å™¨
- **IO instruction**: guest æ‰§è¡Œ I/O æŒ‡ä»¤

**è¯´æ˜**:
- **VMLAUNCH**: å¯åŠ¨ virtual machine çš„æŒ‡ä»¤
- **VM-resume**: ä» VM-exit è¿”å›ç»§ç»­æ‰§è¡Œçš„æŒ‡ä»¤
- **VM-exit reason**: æŒ‡ç¤º VM-exit çš„åŸå› 

---

# 6. æœªå®Œæˆçš„å·¥ä½œ

## 6.1 VM-Entry å¤±è´¥ (é”™è¯¯ç  0x7)

**é—®é¢˜æè¿°**:
- æ‰§è¡Œ VMLAUNCH æ—¶å¤±è´¥ï¼ŒVM-instruction error = 0x7
- é”™è¯¯ 0x7 è¡¨ç¤º "VM-entry failed due to invalid guest state"

**å°è¯•è¿‡çš„è§£å†³æ–¹æ¡ˆ**:
1. âœ… ä¿®æ­£ VM-entry controls çš„ must-be-0 bits
2. âœ… ä¿®æ­£ CS AR (L=0, D=1 for 32-bit; L=1, D=0 for 64-bit)
3. âœ… ä¿®æ­£ CS limit (æ‰©å±•åˆ° 0xFFFFFFFF)
4. âœ… å°† FS/GS è®¾ç½®ä¸º unusable (AR=0x10000)
5. âœ… ä¿®æ­£ CR4.PAE (CR0.PG=0 æ—¶ PAE=0ï¼ŒCR0.PG=1 æ—¶ PAE=1)
6. âœ… ä¿®æ­£ guest RIP (ä½¿ç”¨çº¿æ€§åœ°å€ 0x100000)
7. âœ… ä¿®æ­£ RFLAGS (bit 1=1, bit 9=1)
8. âœ… åˆ›å»º TSS æè¿°ç¬¦å¹¶è®¾ç½® TR
9. âœ… ä¿®æ­£ GDTR/IDTR limit (0x1F/0xFFF)
10. âœ… è®¾ç½® IA32_EFER.LMA=1 (64-bit long mode)
11. âœ… ä¿®æ­£ VMCS ç¼–ç  (VMCS_GUEST_RIP, VMCS_GUEST_GDTR_LIMIT ç­‰)

**å¯èƒ½çš„åŸå› **:
1. â“ EPT æ˜ å°„å¯èƒ½ä¸æ­£ç¡®ï¼ˆguest physical address 0x100000 æœªæ­£ç¡®æ˜ å°„åˆ° host physical addressï¼‰
2. â“ Guest é¡µè¡¨æœªæ­£ç¡®åˆå§‹åŒ–æˆ–æœªè¢« EPT æ˜ å°„
3. â“ VMCS æŸäº›å­—æ®µä»æœ‰é…ç½®é”™è¯¯
4. â“ Host çŠ¶æ€é…ç½®ä¸æ­£ç¡®ï¼ˆç‰¹åˆ«æ˜¯ host CS, RIP, RSPï¼‰
5. â“ VM-entry controls çš„æŸäº›ä½è®¾ç½®é”™è¯¯

**æœªè°ƒè¯•çš„å…³é”®å­—æ®µ**:
- VMCS_GUEST_DEBUGCTL
- VMCS_GUEST_SYSENTER_CS/MSP/EIP
- VMCS_GUEST_PDPTE0-3 (CR0.PG=1, CR4.PAE=1 æ—¶éœ€è¦)
- VMCS_HOST_TR_BASE
- VMCS_HOST_IA32_PAT

## 6.2 EPT æ˜ å°„éªŒè¯

**é—®é¢˜æè¿°**:
- æœªéªŒè¯ EPT æ˜¯å¦æ­£ç¡®æ˜ å°„äº†æ‰€æœ‰ guest physical addresses
- ç‰¹åˆ«éœ€è¦éªŒè¯ï¼š
  - Guest code (0x100000)
  - Guest stack (0x100000)
  - Guest page tables (CR3)
  - GDT/IDT/TSS

**éœ€è¦å®ç°**:
1. âœ… EPT é¡µè¡¨éå†å’Œæ‰“å°
2. âœ… éªŒè¯ç‰¹å®š GPA æ˜¯å¦è¢«æ­£ç¡®æ˜ å°„
3. âœ… æ£€æŸ¥ EPT æƒé™ï¼ˆR/W/Xï¼‰

## 6.3 VM-Exit å¤„ç†å®ç°

**é—®é¢˜æè¿°**:
- å½“å‰ VM-exit å¤„ç†å‡½æ•° `vmexit_handler()` æ˜¯ç©ºçš„
- éœ€è¦å®ç°å®Œæ•´çš„ VM-exit å¤„ç†é€»è¾‘

**éœ€è¦å¤„ç†çš„äº‹ä»¶**:
1. âœ… HLT exit: æ‰“å°æ—¥å¿—å¹¶æš‚åœ guest
2. â“ EPT violation: å¤„ç†ç¼ºå¤±çš„ EPT æ˜ å°„
3. â“ CR access: å¤„ç† guest å¯¹æ§åˆ¶å¯„å­˜å™¨çš„è®¿é—®
4. â“ IO instruction: æ¨¡æ‹Ÿ I/O è®¾å¤‡è®¿é—®
5. â“ CPUID: å¤„ç† CPUID æŒ‡ä»¤
6. â“ MSR access: å¤„ç† MSR è¯»å†™

**ç¤ºä¾‹ä»£ç **:
```rust
pub fn vmexit_handler(ctx: &mut VmCpuRegisters) {
    let exit_reason = vmread(VMCS_EXIT_REASON) & 0xFFFF;
    
    match exit_reason {
        12 => { // HLT exit
            ax_println!("Guest executed HLT");
            // æš‚åœ guest
        }
        48 => { // EPT violation
            let gpa = vmread(VMCS_GUEST_PHYSICAL_ADDRESS);
            ax_println!("EPT violation at GPA {:#x}", gpa);
            // å¤„ç† EPT æ˜ å°„
        }
        _ => {
            panic!("Unhandled VM-exit reason: {}", exit_reason);
        }
    }
}
```

---

# 7. æ ¸å¿ƒè¯´æ˜

## 7.1 Intel VT-x è™šæ‹ŸåŒ–æ¶æ„

### 7.1.1 VMX æ“ä½œæ¨¡å¼

**ä¸¤ç§æ“ä½œæ¨¡å¼**:

| æ¨¡å¼ | æè¿° | æƒé™ |
|------|------|------|
| VMX root operation | Hypervisor è¿è¡Œæ¨¡å¼ | å¯ä»¥æ‰§è¡Œæ‰€æœ‰ VMX æŒ‡ä»¤ |
| VMX non-root operation | Guest æ“ä½œç³»ç»Ÿè¿è¡Œæ¨¡å¼ | å—é™ï¼ŒæŸäº›æ“ä½œè§¦å‘ VM-exit |

**æ¨¡å¼è½¬æ¢**:
- **Entry**: VMLAUNCH/VMRESUME ä» root è¿›å…¥ non-root
- **Exit**: VM-exit ä» non-root è¿”å› root

### 7.1.2 VMCS (Virtual Machine Control Structure)

**VMCS åŒºåŸŸ**:
- **Guest-state area**: å­˜å‚¨ guest å¯„å­˜å™¨çŠ¶æ€
- **Host-state area**: å­˜å‚¨ host å¯„å­˜å™¨çŠ¶æ€
- **VM-execution controls**: æ§åˆ¶ VMX è¡Œä¸º
- **VM-exit controls**: æ§åˆ¶ VM-exit è¡Œä¸º
- **VM-entry controls**: æ§åˆ¶ VM-entry è¡Œä¸º

**VMCS ç¼–ç **:
- æ¯ä¸ª VMCS å­—æ®µæœ‰ä¸€ä¸ªå”¯ä¸€çš„ç¼–ç 
- é€šè¿‡ VMREAD/VMWRITE æŒ‡ä»¤è®¿é—®
- ç¼–ç æ ¼å¼: bits 13:1 = index, bits 14-15 = width, bit 31 = type

### 7.1.3 VM-Entry å’Œ VM-Exit

**VM-Entry æµç¨‹**:
```
1. æ£€æŸ¥ VM-entry controls
2. æ£€æŸ¥ guest stateï¼ˆCR0, CR4, CS, RIP, RFLAGS, GDTR/IDTR, TR/LDTR ç­‰ï¼‰
3. æ£€æŸ¥ host stateï¼ˆCR0/CR3/CR4, CS, RIP, RSP, IA32_EFER ç­‰ï¼‰
4. åŠ è½½ guest state åˆ° CPU
5. è·³è½¬åˆ° guest RIP
```

**VM-Exit æµç¨‹**:
```
1. ä¿å­˜ guest state åˆ° VMCS
2. æ›´æ–° VM-exit information
3. åŠ è½½ host state åˆ° CPU
4. è·³è½¬åˆ° host RIPï¼ˆVM-exit handlerï¼‰
```

**VM-Exit åŸå› ** (éƒ¨åˆ†):
| åŸå› ç  | æè¿° | å¸¸è§åŸå›  |
|--------|------|---------|
| 12 | HLT | guest æ‰§è¡Œ HLT æŒ‡ä»¤ |
| 28 | CONTROL_REGISTER_ACCESS | guest è®¿é—® CR0/CR4 |
| 30 | IO_INSTRUCTION | guest æ‰§è¡Œ IN/OUT æŒ‡ä»¤ |
| 31 | RDMSR/WRMSR | guest è®¿é—® MSR |
| 48 | EPT_VIOLATION | EPT æ˜ å°„å¤±è´¥ |
| 10 | CPUID | guest æ‰§è¡Œ CPUID |

## 7.2 å†…å­˜è™šæ‹ŸåŒ–

### 7.2.1 ä¸¤ç§è™šæ‹ŸåŒ–æ–¹å¼

**æ–¹å¼ 1: Shadow Paging (å½±å­é¡µè¡¨)**
- Hypervisor ç»´æŠ¤ guest é¡µè¡¨çš„å‰¯æœ¬
- Guest ä¿®æ”¹é¡µè¡¨æ—¶ï¼ŒHypervisor åŒæ­¥æ›´æ–° shadow é¡µè¡¨
- ç¼ºç‚¹ï¼šå¤æ‚ï¼Œæ€§èƒ½å·®

**æ–¹å¼ 2: EPT (Extended Page Tables)**
- ä½¿ç”¨ç‹¬ç«‹çš„é¡µè¡¨å®ç° guest physical â†’ host physical æ˜ å°„
- Guest å¯ä»¥è‡ªç”±ä¿®æ”¹è‡ªå·±çš„é¡µè¡¨
- ä¼˜ç‚¹ï¼šç®€å•ï¼Œæ€§èƒ½å¥½

### 7.2.2 åœ°å€è½¬æ¢å±‚æ¬¡

**å¯ç”¨ EPT + Guest Paging**:
```
Guest Linear Address (GLA)
  â””â”€ Guest Page Tables (CR3)
      â””â”€ Guest Physical Address (GPA)
          â””â”€ EPT (EPTP)
              â””â”€ Host Physical Address (HPA)
```

**å¯ç”¨ EPT + No Guest Paging (CR0.PG=0)**:
```
Guest Linear Address (GLA)
  â””â”€ Guest Physical Address (GPA) [identity]
      â””â”€ EPT (EPTP)
          â””â”€ Host Physical Address (HPA)
```

**ç¦ç”¨ EPT + Guest Paging**:
```
Guest Linear Address (GLA)
  â””â”€ Guest Page Tables (CR3)
      â””â”€ Host Physical Address (HPA) [shadow paging]
```

### 7.2.3 EPT PTE æ ¼å¼

| ä½ | å­—æ®µ | æè¿° |
|----|------|------|
| 51:12 | Page Frame Number | ç‰©ç†é¡µå· |
| 11:9 | Ignored | ä¿ç•™ |
| 8 | Ignored for accessed/dirty | å¿½ç•¥ |
| 7:5 | Memory Type | å†…å­˜ç±»å‹ |
| 3 | Execute for reads | æ‰§è¡Œæƒé™ |
| 2 | Write | å†™æƒé™ |
| 1 | Read | è¯»æƒé™ |
| 0 | Read | é¡µå­˜åœ¨ |

## 7.3 æ®µæœºåˆ¶

### 7.3.1 æ®µæè¿°ç¬¦æ ¼å¼

**32-bit æ®µæè¿°ç¬¦**:
```
| Base (31:24) | G | AVL | 0 | Limit (19:16) | P | DPL | S | Type | Base (23:16) |
| Base (15:0) | Limit (15:0) |
```

**å­—æ®µè¯´æ˜**:
- **Base**: æ®µåŸºå€
- **Limit**: æ®µé™åˆ¶
- **G**: Granularity (0=byte, 1=4KB)
- **P**: Present (æ®µæ˜¯å¦åœ¨å†…å­˜ä¸­)
- **DPL**: Descriptor Privilege Level (0-3)
- **S**: System (0=system, 1=code/data)
- **Type**: æ®µç±»å‹

### 7.3.2 ä»£ç æ®µç±»å‹

| Type | L | D | æè¿° |
|------|---|---|------|
| Execute-Only, Accessed | 0 | 0 | 32-bit ä»£ç æ®µ |
| Execute-Read, Accessed | 0 | 0 | 32-bit å¯è¯»ä»£ç æ®µ |
| Execute-Only, Accessed | 1 | - | 64-bit ä»£ç æ®µ |
| Execute-Read, Accessed | 1 | - | 64-bit å¯è¯»ä»£ç æ®µ |

## 7.4 æ§åˆ¶å¯„å­˜å™¨

### 7.4.1 CR0

| ä½ | å­—æ®µ | æè¿° |
|----|------|------|
| 0 | PE | Protection Enable (ä¿æŠ¤æ¨¡å¼) |
| 31 | PG | Paging Enable (åˆ†é¡µå¯ç”¨) |

**æ¨¡å¼**:
- **Real Mode**: PE=0, PG=0
- **Protected Mode**: PE=1, PG=0
- **Long Mode**: PE=1, PG=1, IA32_EFER.LMA=1

### 7.4.2 CR4

| ä½ | å­—æ®µ | æè¿° |
|----|------|------|
| 5 | PAE | Physical Address Extension (PAE å¯ç”¨) |
| 13 | VMXE | VMX Enable (VMX å¯ç”¨) |

**è¦æ±‚**:
- 64-bit long mode éœ€è¦ PAE=1
- VT-x éœ€è¦ VMXE=1

### 7.4.3 IA32_EFER

| ä½ | å­—æ®µ | æè¿° |
|----|------|------|
| 8 | LME | Long Mode Enable (LME å¯ç”¨) |
| 10 | LMA | Long Mode Active (LMA æ¿€æ´») |

**å¯ç”¨ 64-bit long mode**:
1. CR0.PE=1, CR0.PG=0
2. IA32_EFER.LME=1
3. CR4.PAE=1
4. åŠ è½½ 64-bit ä»£ç æ®µï¼ˆCS.L=1ï¼‰
5. CR0.PG=1 (ç°åœ¨ IA32_EFER.LMA=1)

## 7.5 MSR (Model Specific Registers)

**å…³é”® MSR**:

| MSR | åœ°å€ | æè¿° |
|------|------|------|
| IA32_VMX_BASIC | 0x480 | VMX åŸºæœ¬èƒ½åŠ›ä¿¡æ¯ |
| IA32_VMX_PINBASED_CTLS | 0x481 | Pin-based controls |
| IA32_VMX_PROCBASED_CTLS | 0x482 | Processor-based controls |
| IA32_VMX_EXIT_CTLS | 0x483 | VM-exit controls |
| IA32_VMX_ENTRY_CTLS | 0x484 | VM-entry controls |
| IA32_FEATURE_CONTROL | 0x3A | ç‰¹æ€§æ§åˆ¶ MSR |

**MSR è®¿é—®**:
- **RDMSR**: è¯»å– MSR (EDX:EAX = MSR[63:0])
- **WRMSR**: å†™å…¥ MSR (EDX:EAX = MSR[63:0])

**VMX MSR Controls**:
æ¯ä¸ª control MSR åŒ…å«ä¸¤ä¸ª 32-bit å€¼:
- Bits 31:0: must-be-1 bits (å¿…é¡»ä¸º 1 çš„ä½)
- Bits 63:32: must-be-0 bits (å¿…é¡»ä¸º 0 çš„ä½)

---

## ä»£ç ç»“æ„

### æ–‡ä»¶ç»„ç»‡

```
tour/x_1_0/
â”œâ”€â”€ Cargo.toml          # é¡¹ç›®é…ç½®
â””â”€â”€ src/
    â”œâ”€â”€ main.rs         # ä¸»ç¨‹åºï¼Œguest å‡†å¤‡å’Œå¯åŠ¨
    â”œâ”€â”€ loader.rs       # ELF åŠ è½½å™¨
    â”œâ”€â”€ regs.rs         # å¯„å­˜å™¨å®šä¹‰
    â”œâ”€â”€ task.rs         # ä»»åŠ¡ç®¡ç†
    â”œâ”€â”€ vcpu.rs         # VCPU æ•°æ®ç»“æ„
    â””â”€â”€ vmx.rs         # VMX æŒ‡ä»¤å’Œ VMCS ç®¡ç†
```

### æ¨¡å—è¯´æ˜

#### main.rs

**ä¸»è¦å‡½æ•°**:
- `create_gdt()`: åˆ›å»ºå…¨å±€æè¿°ç¬¦è¡¨
- `create_idt()`: åˆ›å»ºä¸­æ–­æè¿°ç¬¦è¡¨
- `create_identity_pagetable()`: åˆ›å»º identity é¡µè¡¨
- `prepare_guest_context()`: å‡†å¤‡ guest ä¸Šä¸‹æ–‡
- `run_guest()`: è¿è¡Œ guest

**å…³é”®æ•°æ®ç»“æ„**:
```rust
struct VmCpuRegisters {
    guest_state: GuestState,
    host_state: HostState,
    // ...
}
```

#### vmx.rs

**ä¸»è¦å‡½æ•°**:
- `vmx_init()`: åˆå§‹åŒ– VMX
- `vmx_cleanup()`: æ¸…ç† VMX
- `setup_vmcs()`: è®¾ç½® VMCS
- `setup_vmcs_host_state()`: è®¾ç½® host çŠ¶æ€
- `setup_vmcs_guest_state()`: è®¾ç½® guest çŠ¶æ€
- `setup_vmcs_controls()`: è®¾ç½® controls
- `vmx_launch()`: å¯åŠ¨ VM (VMLAUNCH)

**å…³é”®å¸¸é‡**:
```rust
// VMCS ç¼–ç  (éƒ¨åˆ†)
const VMCS_GUEST_RIP: u32 = 0x0000681E;
const VMCS_GUEST_CR0: u32 = 0x00006800;
const VMCS_GUEST_CS_SELECTOR: u32 = 0x0000802;
const VMCS_GUEST_CS_AR_BYTES: u32 = 0x0000488A;
// ...
```

**å…³é”®å‡½æ•°**:
```rust
unsafe fn vmread(field: u32) -> u64 {
    let value: u64;
    asm!("vmread {}, {}", out(reg) value, in(reg) field);
    value
}

unsafe fn vmwrite(field: u32, value: u64) {
    asm!("vmwrite {}, {}", in(reg) field, in(reg) value);
}
```

#### loader.rs

**ä¸»è¦å‡½æ•°**:
- `load_vm_image()`: åŠ è½½ VM é•œåƒ
- `open_image_file()`: æ‰“å¼€é•œåƒæ–‡ä»¶
- `load_elf()`: åŠ è½½ ELF æ ¼å¼æ–‡ä»¶

**åŠŸèƒ½**:
- è§£æ ELF header
- åŠ è½½ program headers åˆ°å†…å­˜
- è¿”å›å…¥å£ç‚¹åœ°å€

---
# ä¸¤é˜¶æ®µåœ°å€æ˜ å°„åŸç†å’Œå®ç°

åœ¨ x86_64 è™šæ‹ŸåŒ–ç¯å¢ƒä¸­ï¼Œåœ°å€è½¬æ¢é‡‡ç”¨ä¸¤é˜¶æ®µæ˜ å°„æœºåˆ¶ï¼š

1. **ç¬¬ä¸€é˜¶æ®µ**ï¼šGuest è™šæ‹Ÿåœ°å€ (GVA) â†’ Guest ç‰©ç†åœ°å€ (GPA)
2. **ç¬¬äºŒé˜¶æ®µ**ï¼šGuest ç‰©ç†åœ°å€ (GPA) â†’ Host ç‰©ç†åœ°å€ (HPA)

è¿™ç§æœºåˆ¶å®ç°äº† Guest OS çš„å†…å­˜éš”ç¦»å’Œ Host çš„å†…å­˜ç®¡ç†ç‹¬ç«‹æ€§ã€‚

## åœ°å€è½¬æ¢æµç¨‹å›¾

```
Guest Virtual Address (GVA)
    â”‚
    â”‚ Guest Page Tables (EPTç¦ç”¨)
    â”‚ æˆ– EPT Passthrough (EPTå¯ç”¨ä½†GPA=HPA)
    â–¼
Guest Physical Address (GPA)
    â”‚
    â”‚ Extended Page Tables (EPT)
    â”‚
    â–¼
Host Physical Address (HPA)
```

## è¯¦ç»†æ˜ å°„æœºåˆ¶

### 1. ç¬¬ä¸€é˜¶æ®µï¼šGVA â†’ GPA

#### 1.1 æ ‡å‡†åˆ†é¡µæœºåˆ¶ï¼ˆEPT ç¦ç”¨æˆ–æœªä½¿ç”¨ï¼‰

å½“ EPT è¢«ç¦ç”¨æˆ–é‡‡ç”¨ç›´é€šæ¨¡å¼æ—¶ï¼ŒGuest ä½¿ç”¨æ ‡å‡† x86_64 åˆ†é¡µï¼š

```
GVA (48 bits)
â”‚
â”œâ”€ PML4 Entry (9 bits) â†’ Page Map Level 4 Table
â”‚  â””â”€ PML4E[0..511] æŒ‡å‘ PDPT
â”‚
â”œâ”€ PDPT Entry (9 bits) â†’ Page Directory Pointer Table
â”‚  â””â”€ PDPTE[0..511] æŒ‡å‘ PD
â”‚
â”œâ”€ PD Entry (9 bits) â†’ Page Directory
â”‚  â””â”€ PDE[0..511] æŒ‡å‘ PT
â”‚
â”œâ”€ PT Entry (9 bits) â†’ Page Table
â”‚  â””â”€ PTE[0..511] æŒ‡å‘ç‰©ç†é¡µ
â”‚
â””â”€ Page Offset (12 bits) â†’ é¡µå†…åç§»
```

**CR3 å¯„å­˜å™¨**ï¼š
```
CR3 = Guest Page Table Base Address (GPA)
```

**é¡µè¡¨é¡¹æ ¼å¼** (PTE/PDE/PDPTE/PML4E)ï¼š
```c
struct PageTableEntry {
    uint64_t present      : 1;    // ç¬¬0ä½ï¼šå­˜åœ¨ä½
    uint64_t writable     : 1;    // ç¬¬1ä½ï¼šå¯å†™ä½
    uint64_t user         : 1;    // ç¬¬2ä½ï¼šç”¨æˆ·ä½
    uint64_t pwt          : 1;    // ç¬¬3ä½ï¼šPage Write Through
    uint64_t pcd          : 1;    // ç¬¬4ä½ï¼šPage Cache Disable
    uint64_t accessed     : 1;    // ç¬¬5ä½ï¼šè®¿é—®ä½
    uint64_t dirty        : 1;    // ç¬¬6ä½ï¼šè„ä½
    uint64_t pat          : 1;    // ç¬¬7ä½ï¼šPage Attribute Table
    uint64_t global       : 1;    // ç¬¬8ä½ï¼šå…¨å±€ä½
    uint64_t available    : 3;    // ç¬¬9-11ä½ï¼šå¯ç”¨ä½
    uint64_t frame        : 40;    // ç¬¬12-51ä½ï¼šç‰©ç†å¸§å·
    uint64_t available2   : 11;    // ç¬¬52-62ä½ï¼šå¯ç”¨ä½
    uint64_t nx           : 1;    // ç¬¬63ä½ï¼šç¦æ­¢æ‰§è¡Œ
};
```

#### 1.2 EPT æ¨¡å¼ï¼ˆä¸¤é˜¶æ®µæ˜ å°„ï¼‰

å½“å¯ç”¨ EPT æ—¶ï¼ŒGuest çš„ CR3 æŒ‡å‘ GPA åœ°å€çš„é¡µè¡¨ï¼š

```
Guest CR3 = GPA of Guest Page Tables
```

GVA â†’ GPA è½¬æ¢ä»ç„¶ä½¿ç”¨ä¸Šè¿°çš„æ ‡å‡†åˆ†é¡µæœºåˆ¶ï¼Œä½†æ‰€æœ‰é¡µè¡¨å’Œé¡µå¸§åœ°å€éƒ½æ˜¯ GPAã€‚

### 2. ç¬¬äºŒé˜¶æ®µï¼šGPA â†’ HPA (EPT)

#### 2.1 EPT ç»“æ„

EPT ä½¿ç”¨ä¸æ ‡å‡†åˆ†é¡µç±»ä¼¼çš„ 4 çº§é¡µè¡¨ç»“æ„ï¼Œä½†æ ¼å¼ç•¥æœ‰ä¸åŒï¼š

```
GPA (48 bits)
â”‚
â”œâ”€ PML4 Entry (9 bits) â†’ EPT PML4 Table (HPA)
â”‚  â””â”€ EPT PML4E æŒ‡å‘ EPT PDPT
â”‚
â”œâ”€ PDPT Entry (9 bits) â†’ EPT Page Directory Pointer Table (HPA)
â”‚  â””â”€ EPT PDPTE æŒ‡å‘ EPT PD
â”‚
â”œâ”€ PD Entry (9 bits) â†’ EPT Page Directory (HPA)
â”‚  â””â”€ EPT PDE æŒ‡å‘ EPT PT
â”‚
â”œâ”€ PT Entry (9 bits) â†’ EPT Page Table (HPA)
â”‚  â””â”€ EPT PTE æŒ‡å‘ç‰©ç†é¡µ (HPA)
â”‚
â””â”€ Page Offset (12 bits) â†’ é¡µå†…åç§»
```

#### 2.2 EPTP å¯„å­˜å™¨

EPTP (EPT Pointer) å­˜å‚¨åœ¨ VMCS ä¸­ï¼š

```
VMCS Field: EPT_POINTER (0x201A)

EPTP æ ¼å¼:
| Bits | å­—æ®µ             | è¯´æ˜
|-------|------------------|--------------------------
| 2:0   | Memory Type      | 0=UC, 6=WB (é€šå¸¸ä½¿ç”¨ WB)
| 5:3   | Page Walk Length | 3=4çº§é¡µè¡¨
| 6      | Dirty Flag Enable | è„ä½æ”¯æŒ
| 11:7   | Reserved         | å¿…é¡»ä¸º0
| N-1:12 | EPT PML4 Address| EPT é¡µè¡¨ç‰©ç†åœ°å€ (HPAï¼Œ4KBå¯¹é½)
| 63:N    | Reserved         | å¿…é¡»ä¸º0
```

**EPTP å€¼ç¤ºä¾‹**ï¼š
```c
uint64_t eptp = (HPA_of_EPT_PML4 & 0xFFFFF000) |  // é¡µè¡¨ç‰©ç†åœ°å€
                 (3 << 3) |                     // 4çº§é¡µè¡¨
                 (6 << 0);                     // Write-Back å†…å­˜ç±»å‹
```

#### 2.3 EPT é¡µè¡¨é¡¹æ ¼å¼

```c
struct EPTPageTableEntry {
    uint64_t read          : 1;    // ç¬¬0ä½ï¼šè¯»æƒé™ (R)
    uint64_t write         : 1;    // ç¬¬1ä½ï¼šå†™æƒé™ (W)
    uint64_t execute       : 1;    // ç¬¬2ä½ï¼šæ‰§è¡Œæƒé™ (X)
    uint64_t reserved1     : 5;    // ç¬¬3-7ä½ï¼šä¿ç•™
    uint64_t accessed      : 1;    // ç¬¬8ä½ï¼šè®¿é—®ä½
    uint64_t dirty         : 1;    // ç¬¬9ä½ï¼šè„ä½
    uint64_t user_executable: 1;    // ç¬¬10ä½ï¼šç”¨æˆ·å¯æ‰§è¡Œ
    uint64_t ignored1      : 1;    // ç¬¬11ä½ï¼šå¿½ç•¥
    uint64_t phys_frame    : 40;   // ç¬¬12-51ä½ï¼šç‰©ç†å¸§å· (HPA)
    uint64_t ignored2      : 12;   // ç¬¬52-63ä½ï¼šå¿½ç•¥
};
```

**æƒé™è¯´æ˜**ï¼š
- **R=0, W=0, X=0**ï¼šé¡µé¢ä¸å­˜åœ¨ï¼Œè§¦å‘ EPT Violation
- **R=1, W=0, X=1**ï¼šåªè¯»å¯æ‰§è¡Œé¡µé¢
- **R=1, W=1, X=1**ï¼šè¯»å†™å¯æ‰§è¡Œé¡µé¢
- **R=1, W=1, X=0**ï¼šè¯»å†™ä¸å¯æ‰§è¡Œé¡µé¢ï¼ˆæ•°æ®é¡µé¢ï¼‰

## ä¸¤é˜¶æ®µæ˜ å°„çš„å®Œæ•´è½¬æ¢è¿‡ç¨‹

### åœºæ™¯1ï¼šGuest è¯»å–å†…å­˜

```
1. Guest æ‰§è¡ŒæŒ‡ä»¤: MOV RAX, [0x12345678] (GVA)

2. ç¬¬ä¸€é˜¶æ®µï¼šGVA â†’ GPA
   â”œâ”€ ä½¿ç”¨ Guest CR3 (GPA) æŸ¥æ‰¾ Guest é¡µè¡¨
   â”œâ”€ éå† PML4 â†’ PDPT â†’ PD â†’ PT
   â”œâ”€ è·å¾—é¡µå¸§å· (GPAçš„é«˜ä½)
   â””â”€ è®¡ç®— GPA = Page_Frame(GPA) + Offset(GVA)

3. ç¬¬äºŒé˜¶æ®µï¼šGPA â†’ HPA
   â”œâ”€ ä½¿ç”¨ VMCS.EPTP (HPA) æŸ¥æ‰¾ EPT
   â”œâ”€ éå† EPT PML4 â†’ EPT PDPT â†’ EPT PD â†’ EPT PT
   â”œâ”€ è·å¾— HPA é¡µå¸§å·
   â”œâ”€ æ£€æŸ¥æƒé™ (R=1)
   â””â”€ è®¡ç®— HPA = Page_Frame(HPA) + Offset(GPA)

4. æœ€ç»ˆè®¿é—®ï¼šCPU è®¿é—® HPA åœ°å€çš„ç‰©ç†å†…å­˜
```

### åœºæ™¯2ï¼šEPT Violation

å½“ Guest è®¿é—®æœªæ˜ å°„æˆ–æƒé™ä¸è¶³çš„å†…å­˜æ—¶ï¼š

```
1. Guest è®¿é—® GPA 0x1000 (æœªåœ¨ EPT ä¸­æ˜ å°„)

2. EPT ç¡¬ä»¶æ£€æŸ¥å¤±è´¥
   â”œâ”€ åœ¨ EPT ä¸­æŸ¥æ‰¾ GPA 0x1000
   â””â”€ æœªæ‰¾åˆ°æˆ–æƒé™ä¸è¶³ (R=0 æˆ– W=0)

3. è§¦å‘ VM-Exit
   â””â”€ Exit Reason: EPT_VIOLATION (48)

4. Hypervisor å¤„ç†
   â”œâ”€ è¯»å– Exit Qualification è·å–è¯¦ç»†ä¿¡æ¯
   â”œâ”€ GPA = 0x1000
   â”œâ”€ è¯»å–æƒé™/å†™å…¥æƒé™/æ‰§è¡Œæƒé™
   â””â”€ å†³å®šå¦‚ä½•å¤„ç†ï¼š
       â”œâ”€ åˆ†é…æ–°ç‰©ç†é¡µå¹¶æ›´æ–° EPT
       â”œâ”€ æ¨¡æ‹Ÿ MMIO è®¾å¤‡è®¿é—®
       â””â”€ æ³¨å…¥å¼‚å¸¸åˆ° Guest
```

## å…·ä½“å®ç°

### 1. EPT åˆå§‹åŒ–

#### 1.1 åˆ›å»º Identity Mapping

æœ€ç®€å•çš„å®ç°æ˜¯ 1:1 æ˜ å°„ï¼ŒGPA = HPAï¼š

```c
// å‡è®¾ Guest ä½¿ç”¨ 0-4GB ç‰©ç†åœ°å€ç©ºé—´
void setup_identity_ept(uint64_t *ept_pml4) {
    // EPTP: 4çº§é¡µè¡¨ + WBå†…å­˜ç±»å‹
    uint64_t eptp = (uint64_t)ept_pml4 | (3 << 3) | (6 << 0);

    // ä¸º Guest çš„ 0-4GB ç©ºé—´åˆ›å»º 1:1 æ˜ å°„
    for (uint64_t gpa = 0; gpa < 0x100000000; gpa += 0x200000) {
        // 2MB é¡µé¢ (PDE ç›´æ¥æ˜ å°„)
        uint64_t pd_index = (gpa >> 21) & 0x1FF;
        uint64_t pdpt_index = (gpa >> 30) & 0x1FF;
        uint64_t pml4_index = (gpa >> 39) & 0x1FF;

        // éå†é¡µè¡¨ç»“æ„
        ept_pml4[pml4_index] = allocate_ept_pdpt() | 0x3; // R+W+X
        ept_pdpt[pdpt_index] = allocate_ept_pd() | 0x3;
        ept_pd[pd_index] = gpa | 0x83; // 2MBé¡µé¢ + R+W+X
    }

    // å°† EPTP å†™å…¥ VMCS
    vmwrite(EPT_POINTER, eptp);

    // å¯ç”¨ EPT (è®¾ç½® Secondary Proc-Based VM-Exec Controls)
    uint64_t secondary_ctls = vmread(SECONDARY_VM_EXEC_CONTROLS);
    vmwrite(SECONDARY_VM_EXEC_CONTROLS, secondary_ctls | (1 << 1)); // Bit 1: Enable EPT
}
```

#### 1.2 åœ¨ ArceOS ä¸­çš„å®ç°

```rust
// tour/x_1_0/src/vmcs_control.rs

pub fn create_identity_ept() -> u64 {
    ax_println!("Creating identity-mapped EPT");

    // è·å– host é¡µè¡¨ä½œä¸º EPT (ç®€åŒ–çš„ identity mapping)
    // æ³¨æ„ï¼šå®é™…å®ç°éœ€è¦åˆ†é…ç‹¬ç«‹çš„ EPT é¡µè¡¨
    let (frame, _flags) = x86_64::registers::control::Cr3::read_raw();
    let eptp_phys = frame.start_address().as_u64();

    // EPTP æ ¼å¼ï¼š[ç‰©ç†åœ°å€] | [4çº§é¡µè¡¨(3<<3)] | [WBå†…å­˜ç±»å‹(6<<0)]
    let eptp = eptp_phys | (3 << 3) | (6 << 0);

    ax_println!("EPT pointer (CR3): {:#x}", eptp_phys);
    ax_println!("EPTP value: {:#x}", eptp);

    eptp
}

pub fn setup_ept(eptp: u64) {
    // å†™å…¥ EPT æŒ‡é’ˆåˆ° VMCS
    vmwrite(VmcsField::EptPointer, eptp);

    // å¯ç”¨ EPT (Secondary Proc-Based VM-Exec Controls bit 1)
    let secondary_exec_controls = vmread(VmcsField::ProcBasedVmExecCtl2);
    vmwrite(VmcsField::ProcBasedVmExecCtl2, secondary_exec_controls | (1 << 1));
}
```

### 2. Guest CR3 è®¾ç½®

```rust
// åœ¨ VMCS ä¸­è®¾ç½® Guest CR3
vmwrite(VmcsField::GuestCr3, guest_cr3_gpa);
```

### 3. EPT Violation å¤„ç†

```c
void handle_ept_violation(uint64_t gpa, uint64_t exit_qual) {
    // è§£æ Exit Qualification
    int is_read   = (exit_qual & 0x1) == 0;
    int is_write  = (exit_qual & 0x2) != 0;
    int is_exec  = (exit_qual & 0x4) != 0;
    int gpa_valid = (exit_qual & 0x80) != 0;

    if (!gpa_valid) {
        // GPA æ— æ•ˆï¼Œæ— æ³•ç¡®å®šè®¿é—®åœ°å€
        panic("Invalid GPA in EPT violation");
    }

    if (is_write) {
        // å†™è®¿é—®ï¼šæ›´æ–°è„ä½æˆ–åˆ†é…æ–°é¡µé¢
        allocate_and_map_page(gpa, WRITABLE | EXECUTABLE);
    } else if (is_exec) {
        // æ‰§è¡Œè®¿é—®ï¼šæ˜ å°„ä¸ºå¯æ‰§è¡Œ
        update_ept_permission(gpa, EXECUTABLE);
    }

    // æ¢å¤ guest æ‰§è¡Œ
    vmresume();
}
```

## é«˜çº§ EPT ç‰¹æ€§

### 1. å·¨é¡µæ”¯æŒ

EPT æ”¯æŒ 4KB, 2MB, 1GB é¡µé¢ï¼š

```c
// 2MB é¡µé¢ (PDE)
#define EPT_PDE_PS    (1 << 7)   // Page Size bit
ept_pd[index] = hpa_frame | EPT_PDE_PS | 0x3; // R+W+X

// 1GB é¡µé¢ (PDPTE)
#define EPT_PDPTE_PS  (1 << 7)
ept_pdpt[index] = hpa_frame | EPT_PDPTE_PS | 0x3;
```

**ä¼˜ç‚¹**ï¼š
- å‡å°‘é¡µè¡¨æ¡ç›®æ•°é‡
- å‡å°‘ TLB miss
- æé«˜åœ°å€è½¬æ¢æ€§èƒ½

### 2. EPT Violation Exit Qualification

```
| Bits | å­—æ®µ                    | è¯´æ˜
|-------|------------------------|-------------------
| 0     | Read Access            | 0=è¯»ï¼Œ1=éè¯»
| 1     | Write Access           | 0=éå†™ï¼Œ1=å†™
| 2     | Execute Access        | 0=éæ‰§è¡Œï¼Œ1=æ‰§è¡Œ
| 3     | Readable              | EPTæ¡ç›®çš„è¯»æƒé™
| 4     | Writable              | EPTæ¡ç›®çš„å†™æƒé™
| 5     | Executable            | EPTæ¡ç›®çš„æ‰§è¡Œæƒé™
| 6     | Read for Execute      | ä¸ºæ‰§è¡Œè€Œè¯»
| 7     | Valid GPA             | GPAæœ‰æ•ˆ
| 8     | Caused by Translation | 1=GVAè½¬æ¢å¯¼è‡´ï¼Œ0=GPAè®¿é—®
| 11:9  | NMI Unblocking        | NMIè§£é˜»å¡
| 12    | Shadow Stack Access    | é˜´å½±æ ˆè®¿é—®
| 63:13 | Reserved              | ä¿ç•™
```

### 3. EPT Memory Types

```
| Type | å€¼ | è¯´æ˜
|------|-----|--------------------------
| UC   | 0   | Uncacheable
| WC   | 1   | Write Combining
| WT   | 4   | Write Through
| WP   | 5   | Write Protected
| WB   | 6   | Write Back (æ¨è)
| UC-  | 7   | Uncacheable-
```

## æ€§èƒ½è€ƒè™‘

### 1. EPT Tagging

Intel VT-x æ”¯æŒ EPT Tagging ä»¥ä¼˜åŒ–è™šæ‹ŸåŒ–æ€§èƒ½ï¼š

```c
// EPTP çš„ EPTP bit 6
uint64_t eptp = eptp_phys | (3 << 3) | (6 << 0) | (1 << 6); // å¯ç”¨è„ä½
```

### 2. VPID (Virtual Processor ID)

VPID å…è®¸åœ¨åˆ‡æ¢ Guest æ—¶ä¸åˆ·æ–° TLBï¼š

```c
// è®¾ç½® VPID (0 = ç¦ç”¨ï¼Œ1-0x3FFF = æœ‰æ•ˆ)
vmwrite(VPID, vpid_number);

// ä½¿ TLB æ¡ç›®å¤±æ•ˆ (é’ˆå¯¹ç‰¹å®š VPID)
invept(eptp, INVEPT_SINGLE_CONTEXT);
invvpid(vpid, INVVPID_SINGLE_CONTEXT);
```

## å…¸å‹å†…å­˜å¸ƒå±€

```
Host ç‰©ç†å†…å­˜ (HPA):
0x00000000 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚   Hypervisor ä»£ç /æ•°æ®
â”‚   +----------------+
â”‚   | Host OSå†…æ ¸     |
â”‚   +----------------+
0x10000000 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚   Guest ç‰©ç†å†…å­˜  â”‚
â”‚   +----------------+   EPT æ˜ å°„:
â”‚   | Guest OSå†…æ ¸   |   GPA 0x00000000 â†’ HPA 0x10000000
â”‚   +----------------+
â”‚   | Guest åº”ç”¨ç¨‹åº  â”‚   GPA 0x00100000 â†’ HPA 0x10100000
â”‚   +----------------+
0x20000000 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚   EPT é¡µè¡¨
0x30000000 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚   å…¶ä»–
```

## å®ç°æ­¥éª¤æ€»ç»“

1. **åˆå§‹åŒ– EPT é¡µè¡¨**
   ```rust
   let ept_pml4 = allocate_aligned_page();  // 4KB å¯¹é½
   init_ept_pml4(ept_pml4);
   ```

2. **é…ç½® EPTP**
   ```rust
   let eptp = ept_pml4 as u64 | (3 << 3) | (6 << 0);
   vmwrite(EPT_POINTER, eptp);
   ```

3. **å¯ç”¨ EPT**
   ```rust
   let secondary_ctls = vmread(PROC_BASED_VM_EXEC_CTL2);
   vmwrite(PROC_BASED_VM_EXEC_CTL2, secondary_ctls | (1 << 1));
   ```

4. **è®¾ç½® Guest CR3 (GPA)**
   ```rust
   vmwrite(GUEST_CR3, guest_page_table_gpa);
   ```

5. **å¤„ç† EPT Violation**
   ```rust
   // åœ¨ VM-Exit handler ä¸­
   if exit_reason == EPT_VIOLATION {
       handle_ept_violation(gpa, exit_qual);
   }
   ```

# x86_64 æ¶æ„è™šæ‹Ÿæœºæ—¶é’Ÿä¸­æ–­åŸç†åˆ†æ

## æ¦‚è¿°

åœ¨ x86_64 æ¶æ„çš„è™šæ‹ŸåŒ–ç¯å¢ƒä¸­ï¼Œæ—¶é’Ÿä¸­æ–­æ˜¯ä¸€ä¸ªå…³é”®ä½†å¤æ‚çš„æœºåˆ¶ã€‚å®ƒéœ€è¦è™šæ‹Ÿæœºç›‘è§†å™¨ï¼ˆVMM/Hypervisorï¼‰åœ¨å®¢æˆ·æœºï¼ˆGuestï¼‰å’Œå®¿ä¸»æœºï¼ˆHostï¼‰ä¹‹é—´æ­£ç¡®åœ°æ¨¡æ‹Ÿå’Œä¼ é€’å®šæ—¶äº‹ä»¶ã€‚

### å…³é”®æŒ‘æˆ˜

1. **è™šæ‹ŸåŒ–å®šæ—¶å™¨**ï¼šå®¢æˆ·æœºè®¤ä¸ºå®ƒæ‹¥æœ‰ç‹¬ç«‹çš„å®šæ—¶å™¨ï¼Œä½†å®é™…ä¸Šç”± Hypervisor æ¨¡æ‹Ÿ
2. **ä¸­æ–­æ³¨å…¥**ï¼šHypervisor éœ€è¦åœ¨é€‚å½“çš„æ—¶å€™å‘å®¢æˆ·æœºæ³¨å…¥ä¸­æ–­
3. **æ—¶é—´åŒæ­¥**ï¼šå®¢æˆ·æœºå’Œå®¿ä¸»æœºçš„æ—¶é’Ÿéœ€è¦ä¿æŒåŒæ­¥
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šå‡å°‘ç”±äºè™šæ‹ŸåŒ–å¯¼è‡´çš„æ—¶é’Ÿæ“ä½œå¼€é”€

---

## x86_64 æ—¶é’Ÿä¸­æ–­åŸºç¡€

### 1. ä¼ ç»Ÿç¡¬ä»¶å®šæ—¶å™¨

#### PITï¼ˆå¯ç¼–ç¨‹é—´éš”å®šæ—¶å™¨ï¼Œ8254ï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ä¼ ç»Ÿ x86 å®šæ—¶å™¨ç³»ç»Ÿ              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PIT (8254)   â”‚  LAPIC Timer  â”‚  HPET  â”‚
â”‚  - é€šé“ 0      â”‚  - å®šæ—¶å™¨     â”‚  - å¤šé€šé“â”‚
â”‚  - é€šé“ 1      â”‚  - ä¸­æ–­å‘é‡   â”‚  - é«˜ç²¾åº¦â”‚
â”‚  - é€šé“ 2      â”‚               â”‚         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ç‰¹ç‚¹**ï¼š
- é—ç•™è®¾å¤‡ï¼Œç°ä»£ç³»ç»Ÿå¾ˆå°‘ä½¿ç”¨
- é€šè¿‡ I/O ç«¯å£è®¿é—®ï¼ˆ0x40-0x43ï¼‰
- äº§ç”Ÿ IRQ0ï¼ˆä¸­æ–­å‘é‡ 0x20ï¼‰

#### HPETï¼ˆé«˜ç²¾åº¦äº‹ä»¶å®šæ—¶å™¨ï¼‰

**ç‰¹ç‚¹**ï¼š
- æä¾›çº³ç§’çº§ç²¾åº¦
- å¤šé€šé“ï¼ˆé€šå¸¸ 3 ä¸ªä»¥ä¸Šï¼‰
- å†…å­˜æ˜ å°„ I/O
- ç°ä»£ BIOS/UEFI ç³»ç»Ÿçš„æ ‡å‡†é…ç½®

#### LAPIC Timerï¼ˆæœ¬åœ° APIC å®šæ—¶å™¨ï¼‰

æ¯ä¸ª CPU æ ¸å¿ƒæœ‰ç‹¬ç«‹çš„ LAPIC å®šæ—¶å™¨ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            LAPIC Timer å¯„å­˜å™¨              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Divisor Configuration (32h)             â”‚
â”‚  Initial Count (38h)                     â”‚
â”‚  Current Count (39h)                     â”‚
â”‚  LVT Timer (320h)                      â”‚
â”‚    - Timer Mode (ä½ 17-18)             â”‚
â”‚    - Mask (ä½ 16)                      â”‚
â”‚    - Vector (ä½ 0-7)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å·¥ä½œæ¨¡å¼**ï¼š
- One-shotï¼ˆä¸€æ¬¡æ€§ï¼‰
- Periodicï¼ˆå‘¨æœŸæ€§ï¼‰
- TSC-deadlineï¼ˆåŸºäº TSCï¼Œæ¨èç”¨äºè™šæ‹ŸåŒ–ï¼‰

### 2. TSCï¼ˆæ—¶é—´æˆ³è®¡æ•°å™¨ï¼‰

TSC æ˜¯ä¸€ä¸ª 64 ä½å¯„å­˜å™¨ï¼Œä»å¤„ç†å™¨å¯åŠ¨åæŒç»­é€’å¢ï¼š

```assembly
rdtsc          ; è¯»å– TSC åˆ° EDX:EAX
rdtscp         ; è¯»å– TSC å¹¶è·å–å¤„ç†å™¨ ID
```

**ç‰¹ç‚¹**ï¼š
- é«˜åˆ†è¾¨ç‡ï¼ˆé€šå¸¸æ•° GHzï¼‰
- éæ˜“å¤±æ€§ï¼ˆä¸å—ç”µæºç®¡ç†å½±å“ï¼Œç°ä»£ CPUï¼‰
- æ¯ä¸ª CPU æ ¸å¿ƒï¼ˆæˆ– socketï¼‰æœ‰ç‹¬ç«‹çš„ TSC
- å¯ä»¥é€šè¿‡ `IA32_TSC_AUX_MSR` å’Œ `rdtscp` è®¿é—®

---

## è™šæ‹ŸåŒ–ç¯å¢ƒä¸‹çš„æ—¶é’ŸæŒ‘æˆ˜

### é—®é¢˜ 1ï¼šå®¢æˆ·æœºæ—¶é’Ÿè®¿é—®çš„è™šæ‹ŸåŒ–

**é—®é¢˜**ï¼šå®¢æˆ·æœºç›´æ¥è¯»å– TSC æˆ–é…ç½®å®šæ—¶å™¨ï¼Œä½†ç¡¬ä»¶å±äº Hypervisorã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. **TSC è™šæ‹ŸåŒ–**ï¼šæ¨¡æ‹Ÿ TSC åç§»æˆ–ç¼©æ”¾
2. **LAPIC Timer æ¨¡æ‹Ÿ**ï¼šé€šè¿‡ VM-Exit æ‹¦æˆªæ‰€æœ‰ LAPIC è®¿é—®
3. **HPET/PIT æ¨¡æ‹Ÿ**ï¼šå®Œå…¨è½¯ä»¶æ¨¡æ‹Ÿè¿™äº›è®¾å¤‡

### é—®é¢˜ 2ï¼šå®šæ—¶ç²¾åº¦ä¸å¼€é”€çš„æƒè¡¡

```
ä¼ ç»Ÿæ–¹æ³•ï¼š                è™šæ‹ŸåŒ–æ–¹æ³•ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å®¢æˆ·æœº   â”‚â”€â”€ä¸­æ–­â”€â”€â†’   â”‚ VM-Exit â†’ Hypervisor â”‚
â”‚ è¯»å®šæ—¶å™¨  â”‚             â”‚ å¤„ç†               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ€§èƒ½å½±å“**ï¼š
- æ¯ä¸ª LAPIC è®¿é—®å¯¼è‡´ VM-Exitï¼ˆå¦‚æœæœªä½¿ç”¨è™šæ‹ŸåŒ–åŠŸèƒ½ï¼‰
- æ¯ä¸ª I/O ç«¯å£è®¿é—®å¯¼è‡´ VM-Exitï¼ˆPIT/HPETï¼‰
- VM-Exit å¼€é”€å¯èƒ½æ•°åƒä¸ª CPU å‘¨æœŸ

### é—®é¢˜ 3ï¼šæ—¶é—´åŒæ­¥

**é—®é¢˜**ï¼šå®¢æˆ·æœºå’Œå®¿ä¸»æœºçš„æ—¶é’Ÿå¯èƒ½ä¸åŒæ­¥ã€‚

**åŸå› **ï¼š
- VM-Exit å¯¼è‡´çš„å®¢æˆ·æœºæ—¶é—´"æš‚åœ"
- é¢‘ç‡åå·®ï¼ˆå®¢æˆ·æœº TSC é¢‘ç‡ vs å®¿ä¸»æœº TSC é¢‘ç‡ï¼‰
- å®¢æˆ·æœºæ—¶é—´è¢«ä¿å­˜/æ¢å¤ï¼ˆè¿ç§»åœºæ™¯ï¼‰

---

## VMX è™šæ‹ŸåŒ–æ—¶é’Ÿæœºåˆ¶

### 1. VMCS æ—¶é’Ÿç›¸å…³æ§åˆ¶å­—æ®µ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         VMCS æ—¶é’Ÿæ§åˆ¶å­—æ®µ                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Pin-based VM-execution Controls:             â”‚
â”‚   - External-interrupt exiting (ä½ 0)       â”‚
â”‚                                          â”‚
â”‚ Primary Processor-based VM-execution Controls: â”‚
â”‚   - Use TSC offsetting (ä½ 3)           â”‚
â”‚   - TSC offsetting (ä½ 24)              â”‚
â”‚   - RDTSC exiting (ä½ 12)               â”‚
â”‚   - CR8-load exiting (ä½ 16)              â”‚
â”‚   - CR8-store exiting (ä½ 17)            â”‚
â”‚   - Use TPR shadow (ä½ 21)               â”‚
â”‚   - Virtual-interrupt delivery (ä½ 9)      â”‚
â”‚   - Interrupt-window exiting (ä½ 2)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. MSR ç›¸å…³å­—æ®µ

**TSC ç›¸å…³ MSR**ï¼š

| MSR åœ°å€ | åç§° | åŠŸèƒ½ |
|---------|------|------|
| 0x10 | `IA32_TSC` | TSC å€¼ï¼ˆåªè¯»ï¼‰ |
| 0x3A | `IA32_FEATURE_CONTROL` | ç‰¹æ€§æ§åˆ¶ï¼ˆé”å®šä½ï¼‰ |
| 0x203 | `IA32_TSC_DEADLINE` | TSC-deadline æ¨¡å¼ |
| 0x1B0 | `IA32_TSC_AUX` | TSC è¾…åŠ©å¯„å­˜å™¨ |
| 0xE2 | `IA32_TSC_ADJUST` | TSC è°ƒæ•´å¯„å­˜å™¨ |

### 3. VMX å®šæ—¶å™¨ç‰¹æ€§

**TSC Offsetting**ï¼š
- å…è®¸ä¸ºå®¢æˆ·æœº TSC å€¼æ·»åŠ åç§»
- VMCS å­—æ®µï¼š`VMCS_TSC_OFFSET` (0x2010)
- é¿å…äº† RDTSC VM-Exit

```
å®¢æˆ·æœº TSC = å®é™… TSC + TSC_OFFSET
```

**TSC Scaling**ï¼š
- åœ¨æŸäº› Intel CPU ä¸Šå¯ç”¨
- å…è®¸æŒ‰æ¯”ä¾‹ç¼©æ”¾ TSC å€¼
- ç”¨äºä¸åŒé¢‘ç‡çš„å®¢æˆ·æœº/å®¿ä¸»æœº

---

## TSCï¼ˆæ—¶é—´æˆ³è®¡æ•°å™¨ï¼‰è™šæ‹ŸåŒ–

### 1. åŸºæœ¬åŸç†

#### TSC Offset æœºåˆ¶

```c
// Hypervisor è®¾ç½® TSC åç§»
vmwrite(VMCS_TSC_OFFSET, guest_tsc_offset);

// å®¢æˆ·æœºæ‰§è¡Œ RDTSC æ—¶
// è¿”å›å€¼ = real_tsc + guest_tsc_offset
```

**ç¤ºä¾‹åœºæ™¯**ï¼š

```
å®¿ä¸»æœºå¯åŠ¨æ—¶ TSC = 0
Hypervisor è®¾ç½®å®¢æˆ·æœº TSC åç§» = 0x1_0000_0000

å®¢æˆ·æœºæ‰§è¡Œ RDTSCï¼š
  ç¡¬ä»¶ TSC     = 0x1234_5678
  VMCS åç§»    = 0x1_0000_0000
  å®¢æˆ·æœºçœ‹åˆ°    = 0x1_1234_5678
```

### 2. TSC è™šæ‹ŸåŒ– VM-Exit å¤„ç†

**å½“å®¢æˆ·æœºæ‰§è¡Œ RDTSC/RDTSCP æ—¶**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         RDTSC VM-Exit å¤„ç†æµç¨‹            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. å®¿ä¸»æœºæ•è· RDTSC æŒ‡ä»¤               â”‚
â”‚ 2. Hypervisor è¯»å–å®é™… TSC                â”‚
â”‚ 3. åº”ç”¨ TSC offset                      â”‚
â”‚ 4. å°†ç»“æœå†™å…¥å®¢æˆ·æœºé€šç”¨å¯„å­˜å™¨            â”‚
â”‚ 5. è·³è¿‡æŒ‡ä»¤ï¼ˆadvance RIPï¼‰              â”‚
â”‚ 6. æ¢å¤å®¢æˆ·æœºæ‰§è¡Œ                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä»£ç ç¤ºä¾‹**ï¼š

```rust
// vmx.rs ä¸­çš„å¤„ç†
fn handle_rdtsc_vmexit(ctx: &mut VmCpuRegisters) {
    unsafe {
        // è¯»å–å®é™… TSC
        let tsc: u64;
        core::arch::asm!(
            "rdtsc",
            out("eax") (tsc as u32),
            out("edx") ((tsc >> 32) as u32),
        );
        
        // åº”ç”¨å®¢æˆ·æœº TSC åç§»
        let guest_tsc = tsc + ctx.tsc_offset;
        
        // å°†ç»“æœå†™å…¥å®¢æˆ·æœº RAXï¼ˆRDTSC è¿”å› EDX:EAXï¼‰
        ctx.guest_state.rax = guest_tsc & 0xFFFFFFFF;
        ctx.guest_state.rdx = (guest_tsc >> 32) & 0xFFFFFFFF;
        
        // è·³è¿‡ RDTSC æŒ‡ä»¤ï¼ˆé€šå¸¸æ˜¯ 2 å­—èŠ‚ï¼‰
        ctx.guest_state.rip += 2;
        vmwrite(VMCS_GUEST_RIP, ctx.guest_state.rip);
    }
}
```

### 3. TSC åŒæ­¥å’Œè°ƒæ•´

#### é¢‘ç‡è¡¥å¿

å½“å®¢æˆ·æœº TSC é¢‘ç‡ä¸å®¿ä¸»æœºä¸åŒæ—¶ï¼š

```c
// è®¡ç®—æ¯”ä¾‹å› å­
double tsc_ratio = guest_tsc_frequency / host_tsc_frequency;

// å®¢æˆ·æœºè™šæ‹Ÿ TSC = å®¿ä¸»æœºå®é™… TSC * tsc_ratio
guest_virtual_tsc = (uint64_t)((double)host_actual_tsc * tsc_ratio);
```

#### æ—¶é—´è¿½èµ¶

å¦‚æœå®¢æˆ·æœºæ—¶é—´è½åï¼ˆç”±äº VM-Exitsï¼‰ï¼š

```c
// å‘¨æœŸæ€§æ£€æŸ¥å¹¶è¿½èµ¶
if (guest_tsc < expected_tsc) {
    // å¢åŠ  TSC åç§»
    tsc_offset += (expected_tsc - guest_tsc);
    vmwrite(VMCS_TSC_OFFSET, tsc_offset);
}
```

---

## APIC å®šæ—¶å™¨è™šæ‹ŸåŒ–

### 1. LAPIC Timer æ¦‚è¿°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        LAPIC Timer å·¥ä½œæµç¨‹                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                          â”‚
â”‚  å®¢æˆ·æœºå†™ Divisor                       â”‚
â”‚       â†“                                   â”‚
â”‚  å®¢æˆ·æœºå†™ Initial Count                  â”‚
â”‚       â†“                                   â”‚
â”‚  Timer å¼€å§‹é€’å‡                           â”‚
â”‚       â†“                                   â”‚
â”‚  Count == 0?                            â”‚
â”‚       â†“ æ˜¯                                â”‚
â”‚  ç”Ÿæˆä¸­æ–­åˆ° LVT Timer æŒ‡å®šçš„å‘é‡         â”‚
â”‚       â†“                                   â”‚
â”‚  è‹¥ä¸ºå‘¨æœŸæ¨¡å¼ï¼Œé‡æ–°åŠ è½½ Initial Count      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. LAPIC Timer è®¿é—®çš„è™šæ‹ŸåŒ–

#### MMIO åŒºåŸŸ

LAPIC å¯„å­˜å™¨æ˜ å°„åˆ°ç‰¹å®šçš„ç‰©ç†åœ°å€èŒƒå›´ï¼š

```
LAPIC åŸºåœ°å€ï¼šé€šå¸¸æ˜¯ 0xFEE0_0000ï¼ˆå¯é…ç½®ï¼‰

å®šæ—¶å™¨ç›¸å…³å¯„å­˜å™¨ï¼š
  0x3E0  : Timer LVT
  0x380  : Timer Divide Configuration
  0x390  : Initial Count
  0x391  : Current Countï¼ˆåªè¯»ï¼‰
```

#### EPT Violation å¤„ç†

**å®¢æˆ·æœºè®¿é—® LAPIC æ—¶**ï¼š

```rust
// EPT è¿è§„å¤„ç†æµç¨‹
fn handle_lapic_mmio(paddr: u64, value: u64, is_write: bool) {
    match paddr {
        // Timer Initial Count
        0xFEE0_0390 if is_write => {
            lapic_timer.initial_count = value as u32;
            lapic_timer.current_count = value as u32;
            lapic_timer.running = true;
        }
        
        // Timer Current Countï¼ˆè¯»ï¼‰
        0xFEE0_0391 if !is_write => {
            return lapic_timer.current_count;
        }
        
        // Timer LVT
        0xFEE0_03E0 if is_write => {
            lapic_timer.lvt = value as u32;
        }
        
        _ => unimplemented!(),
    }
}
```

### 3. LAPIC Timer æ¨¡æ‹Ÿ

#### åŸºæœ¬æ¨¡æ‹Ÿé€»è¾‘

```rust
struct LapicTimer {
    pub divide_value: u32,     // åˆ†é¢‘å€¼
    pub initial_count: u32,    // åˆå§‹è®¡æ•°å€¼
    pub current_count: u32,    // å½“å‰è®¡æ•°å€¼
    pub lvt: u32,           // LVT å¯„å­˜å™¨
    pub mode: TimerMode,      // One-shot/Periodic/TSC-deadline
    pub running: bool,
    pub next_deadline: u64,   // ä¸‹ä¸€æ¬¡åˆ°æœŸæ—¶é—´ï¼ˆTSCï¼‰
}

impl LapicTimer {
    // æ¨¡æ‹Ÿæ—¶é’Ÿæ»´ç­”
    pub fn tick(&mut self, tsc: u64) {
        if !self.running {
            return;
        }
        
        match self.mode {
            TimerMode::OneShot => {
                // è®¡ç®—è¿‡æœŸæ—¶é—´
                if tsc >= self.next_deadline {
                    self.current_count = 0;
                    self.running = false;
                    self.fire_interrupt();
                }
            }
            TimerMode::Periodic => {
                if tsc >= self.next_deadline {
                    // é‡æ–°åŠ è½½è®¡æ•°å€¼
                    self.current_count = self.initial_count;
                    // è®¡ç®—ä¸‹ä¸€ä¸ªå‘¨æœŸ
                    let period = self.calculate_period();
                    self.next_deadline += period;
                    self.fire_interrupt();
                }
            }
            TimerMode::TscDeadline => {
                if tsc >= self.tsc_deadline {
                    self.fire_interrupt();
                    self.running = false;
                }
            }
        }
    }
    
    // æ³¨å…¥ä¸­æ–­åˆ°å®¢æˆ·æœº
    fn fire_interrupt(&self) {
        let vector = self.lvt & 0xFF;
        inject_interrupt(vector);
    }
}
```

#### TSC-Deadline æ¨¡å¼

TSC-Deadline æ¨¡å¼æ˜¯æœ€é€‚åˆè™šæ‹ŸåŒ–çš„æ¨¡å¼ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        TSC-Deadline æ¨¡å¼å·¥ä½œæµç¨‹         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                          â”‚
â”‚  å®¢æˆ·æœºå†™ MSR_IA32_TSC_DEADLINE         â”‚
â”‚       â†“                                  â”‚
â”‚  Hypervisor è®°å½• deadline TSC å€¼         â”‚
â”‚       â†“                                  â”‚
â”‚  å®¿ä¸»æœºå‘¨æœŸæ€§æ£€æŸ¥ï¼štsc >= deadline?      â”‚
â”‚       â†“ æ˜¯                               â”‚
â”‚  æ³¨å…¥ä¸­æ–­åˆ°å®¢æˆ·æœº                       â”‚
â”‚       â†“                                  â”‚
â”‚  å®¢æˆ·æœºä¸­æ–­å¤„ç†ç¨‹åºæ‰§è¡Œ                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä¼˜åŠ¿**ï¼š
- åªéœ€è¦ä¸€æ¬¡ MSR å†™å…¥
- æ— å‘¨æœŸæ€§çš„ LAPIC å¯„å­˜å™¨è®¿é—®
- å®Œå…¨é¿å… EPT è¿è§„ï¼ˆå¦‚æœä½¿ç”¨ VMX çš„ TSC-deadline ç‰¹æ€§ï¼‰

---

## æ—¶é’Ÿä¸­æ–­æ³¨å…¥

### 1. è™šæ‹Ÿä¸­æ–­æ§åˆ¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        VMCS ä¸­æ–­æ³¨å…¥å­—æ®µ                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  VM_ENTRY_INTR_INFO (0x4016)             â”‚
â”‚    - Vector (ä½ 0-7)                     â”‚
â”‚    - Interrupt Type (ä½ 8-10)              â”‚
â”‚    - Deliver Error Code (ä½ 11)            â”‚
â”‚    - Valid (ä½ 31)                        â”‚
â”‚                                          â”‚
â”‚  VM_ENTRY_EXCEPTION_ERROR_CODE (0x4018)     â”‚
â”‚    - Error Code (32 ä½)                     â”‚
â”‚                                          â”‚
â”‚  VM_ENTRY_INSTRUCTION_LEN (0x401A)          â”‚
â”‚    - æŒ‡ä»¤é•¿åº¦                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. ä¸­æ–­æ³¨å…¥æµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        æ—¶é’Ÿä¸­æ–­æ³¨å…¥æµç¨‹                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                          â”‚
â”‚  Hypervisor æ£€æµ‹å®šæ—¶å™¨åˆ°æœŸ                â”‚
â”‚       â†“                                  â”‚
â”‚  æ£€æŸ¥å®¢æˆ·æœºä¸­æ–­çŠ¶æ€ï¼ˆRFLAGS.IFï¼‰        â”‚
â”‚       â†“                                  â”‚
â”‚  å¦‚æœ IF=0ï¼ˆä¸­æ–­è¢«å±è”½ï¼‰ï¼š              â”‚
â”‚    è®¾ç½® interruptibility-state               â”‚
â”‚    ç­‰å¾… VM-Exitï¼ˆInterrupt-Windowï¼‰    â”‚
â”‚  å¦‚æœ IF=1ï¼ˆä¸­æ–­ä½¿èƒ½ï¼‰ï¼š                 â”‚
â”‚    å‡†å¤‡ VM_ENTRY_INTR_INFO               â”‚
â”‚    è®¾ç½® interrupt-type = External Interrupt   â”‚
â”‚    è®¾ç½® vector = LAPIC å®šæ—¶å™¨å‘é‡         â”‚
â”‚    è®¾ç½® valid = 1                        â”‚
â”‚       â†“                                  â”‚
â”‚  åœ¨ä¸‹ä¸€æ¬¡ VMRESUME/VMLAUNCH æ—¶æ³¨å…¥       â”‚
â”‚       â†“                                  â”‚
â”‚  å®¢æˆ·æœºæ¥æ”¶ä¸­æ–­ï¼Œæ‰§è¡Œ ISR              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. ä¸­æ–­æ³¨å…¥ä»£ç ç¤ºä¾‹

```rust
// æ³¨å…¥å¤–éƒ¨ä¸­æ–­åˆ°å®¢æˆ·æœº
fn inject_external_interrupt(vector: u8, ctx: &mut VmCpuRegisters) {
    unsafe {
        // 1. æ£€æŸ¥ä¸­æ–­å±è”½çŠ¶æ€
        if ctx.guest_state.rflags & (1 << 9) == 0 {
            // IF=0ï¼Œå®¢æˆ·æœºå±è”½ä¸­æ–­
            // è®¾ç½® Interruptibility stateï¼Œç­‰å¾… Interrupt Window
            ctx.guest_state.interruptibility_state = 1 << 0; // Blocking by STI
            
            // è®¾ç½® Interrupt-Window exiting
            let mut proc_ctrl = vmread(VMCS_PRIMARY_PROC_BASED_VM_EXEC_CONTROL) as u32;
            proc_ctrl |= (1 << 2); // Interrupt window exiting
            vmwrite(VMCS_PRIMARY_PROC_BASED_VM_EXEC_CONTROL, proc_ctrl as u64);
            
            return;
        }
        
        // 2. å‡†å¤‡ä¸­æ–­ä¿¡æ¯
        let intr_info: u64 = (1u64 << 31) |          // Valid
                           (0u64 << 8) |              // Interrupt type: External
                           (vector as u64 & 0xFF);     // Vector
        
        vmwrite(VMCS_VM_ENTRY_INTR_INFO, intr_info);
        
        // 3. æ¢å¤å®¢æˆ·æœºæ‰§è¡Œ
        vmx_resume(ctx);
    }
}
```

### 4. Interrupt Window Exiting

**ç”¨é€”**ï¼šå½“å®¢æˆ·æœºä¸­æ–­è¢«å±è”½æ—¶ï¼Œåœ¨å®ƒæ¸…é™¤å±è”½åç«‹å³é€šçŸ¥ Hypervisorã€‚

**é…ç½®**ï¼š

```c
// å¯ç”¨ Interrupt Window Exiting
uint32_t proc_ctrl = vmread(VMCS_PRIMARY_PROC_BASED_VM_EXEC_CONTROL);
proc_ctrl |= (1 << 2);  // Interrupt window exiting
vmwrite(VMCS_PRIMARY_PROC_BASED_VM_EXEC_CONTROL, proc_ctrl);
```

**VM-Exit åŸå› **ï¼š

```c
// Exit reason = 7 (Interrupt window)
if (exit_reason == 7) {
    // å®¢æˆ·æœºç°åœ¨å¯ä»¥æ¥æ”¶ä¸­æ–­äº†
    // æ¸…é™¤ interruptibility state
    ctx->interruptibility_state = 0;
    
    // æ³¨å…¥ä¸­æ–­
    inject_pending_interrupts(ctx);
    
    // æ¸…é™¤ Interrupt Window Exitingï¼ˆå¦‚æœä¸éœ€è¦ï¼‰
    proc_ctrl &= ~(1 << 2);
    vmwrite(VMCS_PRIMARY_PROC_BASED_VM_EXEC_CONTROL, proc_ctrl);
}
```

---

## VM-Exit äº‹ä»¶å¤„ç†

### 1. æ—¶é’Ÿç›¸å…³ VM-Exit åŸå› 

| é€€å‡ºåŸå›  | ä»£ç  | è¯´æ˜ | å¤„ç†æ–¹æ³• |
|---------|------|------|-----------|
| CR Access | 44 | è®¿é—® CR8ï¼ˆTPRï¼‰ | æ›´æ–° TPR shadow |
| I/O Instruction | 30 | è®¿é—® PIT ç«¯å£ | æ¨¡æ‹Ÿ PIT è®¾å¤‡ |
| RDMSR | 48 | è¯»å– TSC MSR | è¿”å›è™šæ‹ŸåŒ– TSC |
| WRMSR | 49 | å†™å…¥ TSC deadline | è®°å½• deadline |
| EPT Violation | 48 | è®¿é—® LAPIC MMIO | æ¨¡æ‹Ÿ LAPIC å¯„å­˜å™¨ |
| Interrupt Window | 7 | å®¢æˆ·æœº STI æ‰§è¡Œå | æ³¨å…¥å¾…å¤„ç†ä¸­æ–­ |
| RDTSC | 31 | æ‰§è¡Œ RDTSCï¼ˆå¦‚æœå¯ç”¨é€€å‡ºï¼‰ | è¿”å›åç§»çš„ TSC |

### 2. å®Œæ•´çš„ VM-Exit å¤„ç†æ¡†æ¶

```rust
fn vmexit_handler(ctx: &mut VmCpuRegisters) {
    let exit_reason = ctx.guest_state.exit_reason & 0x7FFF;
    let exit_qual = ctx.guest_state.exit_qualification;
    
    match exit_reason {
        // æ—¶é’Ÿç›¸å…³çš„é€€å‡º
        31 => {  // RDTSC
            if ctx.enable_rdtsc_exiting {
                handle_rdtsc(ctx);
            }
        }
        
        44 => {  // CR access
            let cr_num = (exit_qual & 0xF) as u32;
            let access_type = (exit_qual >> 4) & 0x3;
            
            if cr_num == 8 {
                // CR8 (TPR) è®¿é—®
                handle_cr8_access(ctx, access_type);
            }
        }
        
        30 => {  // I/O instruction
            let port = (exit_qual & 0xFFFF) as u16;
            let is_write = (exit_qual & (1 << 3)) != 0;
            
            match port {
                0x40..=0x43 => handle_pit_access(ctx, port, is_write),
                _ => unimplemented!(),
            }
        }
        
        48 => {  // EPT violation
            let gpa = ctx.guest_state.guest_physical_address;
            
            if is_lapic_address(gpa) {
                handle_lapic_access(ctx, gpa);
            }
        }
        
        7 => {  // Interrupt window
            handle_interrupt_window(ctx);
        }
        
        _ => {
            unimplemented!("Unknown exit reason: {}", exit_reason);
        }
    }
}
```

---

## å®é™…å®ç°ç¤ºä¾‹

### ç¤ºä¾‹ 1ï¼šå®Œæ•´çš„ LAPIC Timer è™šæ‹ŸåŒ–

```rust
// lapic_timer.rs
use bitflags::bitflags;

bitflags! {
    pub struct LvtTimer: u32 {
        const TIMER_MASK       = 1 << 16;
        const TIMER_PERIODIC    = 0b01 << 17;
        const TIMER_ONESHOT    = 0b00 << 17;
        const TIMER_TSCDEADLINE= 0b10 << 17;
    }
}

pub struct VirtualLapicTimer {
    pub lvt: LvtTimer,
    pub divide_config: u32,
    pub initial_count: u32,
    pub current_count: u32,
    pub target_tsc: u64,
    pub interrupt_vector: u8,
    pub enabled: bool,
}

impl VirtualLapicTimer {
    pub fn new() -> Self {
        Self {
            lvt: LvtTimer::TIMER_ONESHOT,
            divide_config: 0,
            initial_count: 0,
            current_count: 0,
            target_tsc: 0,
            interrupt_vector: 0,
            enabled: false,
        }
    }
    
    // å®¢æˆ·æœºå†™ Initial Count
    pub fn write_initial_count(&mut self, value: u32) {
        self.initial_count = value;
        self.current_count = value;
        
        if value != 0 {
            self.enabled = true;
            // è®¡ç®—ç›®æ ‡ TSC
            let bus_freq = self.calculate_bus_frequency();
            let period = value as u64 * bus_freq;
            self.target_tsc = read_host_tsc() + period;
        } else {
            self.enabled = false;
        }
    }
    
    // å®¢æˆ·æœºè¯» Current Count
    pub fn read_current_count(&self, host_tsc: u64) -> u32 {
        if !self.enabled {
            return self.current_count;
        }
        
        let elapsed = host_tsc.saturating_sub(self.target_tsc);
        let bus_freq = self.calculate_bus_frequency();
        let elapsed_counts = elapsed / bus_freq;
        
        self.initial_count.saturating_sub(elapsed_counts as u32)
    }
    
    // æ£€æŸ¥æ˜¯å¦åˆ°æœŸ
    pub fn check(&mut self, host_tsc: u64) -> bool {
        if !self.enabled {
            return false;
        }
        
        if host_tsc >= self.target_tsc {
            // å®šæ—¶å™¨åˆ°æœŸ
            if self.lvt.contains(LvtTimer::TIMER_PERIODIC) {
                // å‘¨æœŸæ¨¡å¼ï¼šé‡æ–°åŠ è½½
                let bus_freq = self.calculate_bus_frequency();
                let period = self.initial_count as u64 * bus_freq;
                self.target_tsc = host_tsc + period;
            } else {
                // One-shot æ¨¡å¼ï¼šåœæ­¢
                self.enabled = false;
            }
            
            // æ³¨å…¥ä¸­æ–­
            if !self.lvt.contains(LvtTimer::TIMER_MASK) {
                inject_interrupt(self.interrupt_vector);
            }
            
            return true;
        }
        
        false
    }
    
    fn calculate_bus_frequency(&self) -> u64 {
        // åŸºäº divide configuration è®¡ç®—é¢‘ç‡
        let divisors = [1, 2, 4, 8, 16, 32, 64, 128];
        let index = (self.divide_config & 0x3) as usize;
        divisors[index] as u64
    }
}
```

### ç¤ºä¾‹ 2ï¼šå®šæ—¶å™¨ç®¡ç†å™¨

```rust
// timer_manager.rs
use alloc::collections::BTreeMap;
use alloc::sync::Arc;
use spin::Mutex;

pub struct TimerManager {
    lapic_timer: Mutex<VirtualLapicTimer>,
    tsc_offset: Mutex<i64>,
}

impl TimerManager {
    pub fn new() -> Self {
        Self {
            lapic_timer: Mutex::new(VirtualLapicTimer::new()),
            tsc_offset: Mutex::new(0),
        }
    }
    
    // å¤„ç†å®šæ—¶å™¨åˆ°æœŸ
    pub fn tick(&self) {
        let host_tsc = read_host_tsc();
        let mut timer = self.lapic_timer.lock();
        timer.check(host_tsc);
    }
    
    // è®¾ç½® TSC åç§»ï¼ˆç”¨äºæ—¶é—´è°ƒæ•´ï¼‰
    pub fn set_tsc_offset(&self, offset: i64) {
        let mut tsc_offset = self.tsc_offset.lock();
        *tsc_offset = offset;
        vmwrite(VMCS_TSC_OFFSET, *tsc_offset as u64);
    }
    
    // è·å–å®¢æˆ·æœºè™šæ‹Ÿ TSC
    pub fn get_guest_tsc(&self) -> u64 {
        let host_tsc = read_host_tsc();
        let offset = *self.tsc_offset.lock();
        (host_tsc as i64 + offset).max(0) as u64
    }
}

// å…¨å±€å®šæ—¶å™¨ç®¡ç†å™¨
static TIMER_MANAGER: TimerManager = TimerManager::new();

// å®šæœŸè°ƒç”¨ï¼ˆä¾‹å¦‚ï¼šæ¯ä¸ª VM-Exitï¼‰
pub fn handle_timer_tick() {
    TIMER_MANAGER.tick();
}
```

### ç¤ºä¾‹ 3ï¼šé›†æˆåˆ° Hypervisor ä¸»å¾ªç¯

```rust
// vmx.rs ä¸­çš„é›†æˆ
pub fn run_guest(ctx: &mut VmCpuRegisters) {
    loop {
        unsafe {
            // å¯åŠ¨å®¢æˆ·æœº
            vmlaunch();
            
            // VM-Exit å‘ç”Ÿ
            let exit_reason = ctx.guest_state.exit_reason & 0x7FFF;
            
            // å¤„ç†å®šæ—¶å™¨ç›¸å…³é€€å‡º
            match exit_reason {
                30 => handle_io_instruction(ctx),
                44 => handle_cr_access(ctx),
                48 => handle_ept_violation(ctx),
                7 => handle_interrupt_window(ctx),
                _ => {},
            }
            
            // æ£€æŸ¥å®šæ—¶å™¨
            handle_timer_tick();
            
            // å¦‚æœå®¢æˆ·æœºè¯·æ±‚é€€å‡ºï¼Œè·³å‡ºå¾ªç¯
            if should_exit(ctx) {
                break;
            }
        }
    }
}
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. å‡å°‘æ—¶é’Ÿç›¸å…³ VM-Exit

#### ç­–ç•¥ 1ï¼šä½¿ç”¨ TSC Offsetting

```c
// å¯ç”¨ TSC offsettingï¼Œé¿å… RDTSC VM-Exit
uint32_t proc_ctrl = vmread(VMCS_PRIMARY_PROC_BASED_VM_EXEC_CONTROL);
proc_ctrl |= (1 << 3);   // Use TSC offsetting
proc_ctrl |= (1 << 24);  // TSC offsetting
vmwrite(VMCS_PRIMARY_PROC_BASED_VM_EXEC_CONTROL, proc_ctrl);
```

#### ç­–ç•¥ 2ï¼šä½¿ç”¨ APICvï¼ˆè™šæ‹Ÿ APICï¼‰

```c
// å¯ç”¨ Virtual Interrupt Delivery
uint32_t proc_ctrl = vmread(VMCS_PRIMARY_PROC_BASED_VM_EXEC_CONTROL);
proc_ctrl |= (1 << 9);   // Virtual interrupt delivery
vmwrite(VMCS_PRIMARY_PROC_BASED_VM_EXEC_CONTROL, proc_ctrl);

// å¯ç”¨ TPR Shadow
proc_ctrl |= (1 << 21);  // Use TPR shadow
vmwrite(VMCS_PRIMARY_PROC_BASED_VM_EXEC_CONTROL, proc_ctrl);
```

**ä¼˜åŠ¿**ï¼š
- å®¢æˆ·æœº TPR è®¿é—®ä¸å¯¼è‡´ VM-Exit
- è™šæ‹Ÿä¸­æ–­æ³¨å…¥æ›´å¿«
- å‡å°‘ä¸­æ–­æ³¨å…¥çš„å»¶è¿Ÿ

#### ç­–ç•¥ 3ï¼šä½¿ç”¨ Posted Interrupts

```c
// å¯ç”¨ Posted Interruptsï¼ˆéœ€è¦ç¡¬ä»¶æ”¯æŒï¼‰
uint32_t pin_ctrl = vmread(VMCS_PIN_BASED_VM_EXEC_CONTROL);
pin_ctrl |= (1 << 6);   // Process posted interrupts
vmwrite(VMCS_PIN_BASED_VM_EXEC_CONTROL, pin_ctrl);
```

### 2. æ‰¹é‡å¤„ç†å®šæ—¶å™¨

```rust
// ä¸æ˜¯æ¯ä¸ª VM-Exit éƒ½æ£€æŸ¥å®šæ—¶å™¨
// è€Œæ˜¯å®šæœŸæ‰¹é‡æ£€æŸ¥
const TIMER_CHECK_INTERVAL_MS: u64 = 1;

pub fn vmx_run(ctx: &mut VmCpuRegisters) {
    let mut next_timer_check = read_host_tsc();
    
    loop {
        vmlaunch();
        
        let now = read_host_tsc();
        if now >= next_timer_check {
            // æ‰¹é‡å¤„ç†å¤šä¸ªå®šæ—¶å™¨
            handle_timer_tick();
            next_timer_check = now + tsc_from_ms(TIMER_CHECK_INTERVAL_MS);
        }
        
        if should_exit(ctx) {
            break;
        }
    }
}
```

### 3. æ— é”å®šæ—¶å™¨é˜Ÿåˆ—

```rust
// ä½¿ç”¨ per-CPU æ•°æ®ç»“æ„ï¼Œé¿å…é”ç«äº‰
static PER_CPU_TIMERS: [PerCpuTimerManager; MAX_CPUS] = [
    PerCpuTimerManager::new(),
    PerCpuTimerManager::new(),
    // ...
];

pub struct PerCpuTimerManager {
    timers: Mutex<Vec<TimerEvent>>,
    // ä¸éœ€è¦ä¸å…¶ä»– CPU åŒæ­¥
}
```

### 4. ä½¿ç”¨ç¡¬ä»¶ç‰¹æ€§

**VT-x Preemption Timer**ï¼š

```c
// å¯ç”¨è™šæ‹Ÿæœº preemption timer
uint32_t pin_ctrl = vmread(VMCS_PIN_BASED_VM_EXEC_CONTROL);
pin_ctrl |= (1 << 6);  // Enable VMX preemption timer
vmwrite(VMCS_PIN_BASED_VM_EXEC_CONTROL, pin_ctrl);

// è®¾ç½®å®šæ—¶å™¨å€¼ï¼ˆå•ä½ï¼šVMCS ä¸­çš„åˆ†è¾¨ç‡ï¼‰
vmwrite(VMCS_VMX_PREEMPTION_TIMER_VALUE, timeout_value);
```

**ä¼˜åŠ¿**ï¼š
- æ— éœ€è½¯ä»¶æ£€æŸ¥
- ç¡¬ä»¶ç²¾ç¡®è§¦å‘ VM-Exit
- å¯ä»¥ç”¨äºæ—¶é—´ç‰‡è°ƒåº¦

---


